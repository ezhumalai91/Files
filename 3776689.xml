<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//NLM//DTD JATS (Z39.96) Journal Archiving and Interchange DTD with OASIS Tables with MathML3 v1.2d1 20170631//EN" "JATS-archive-oasis-article1-mathml3.dtd">
<article dtd-version="1.2d1" xml:lang="en" article-type="research-article" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
<front>
<journal-meta>
<journal-id journal-id-type="acm-id">J1568</journal-id>
<journal-id journal-id-type="publisher-id">PACMPL</journal-id>
<journal-title-group>
<journal-title>Proceedings of the ACM on Programming Languages</journal-title>
</journal-title-group>
<issn pub-type="epub">2475-1421</issn>
<publisher>
<publisher-name>ACM</publisher-name>
<publisher-name specific-use="publisher-id db-only">PUB27</publisher-name>
<publisher-loc>New York, NY, USA</publisher-loc>
</publisher>
</journal-meta>
<article-meta>
<article-id pub-id-type="acm-id">3776689</article-id>
<article-id pub-id-type="doi">10.1145/3776689</article-id>
<article-id pub-id-type="manuscript_tracking_id">popl26main-p285-p</article-id>
<article-id pub-id-type="article-no">47</article-id>
<article-categories>
<subj-group subj-group-type="paper-type">
<compound-subject>
<compound-subject-part content-type="code">full-paper</compound-subject-part>
<compound-subject-part content-type="text">Full-Paper</compound-subject-part>
</compound-subject>
</subj-group>
<subj-group subj-group-type="ccs2012">
<compound-subject>
<compound-subject-part content-type="code">10003752.10003766</compound-subject-part>
<compound-subject-part content-type="text">Theory of computation~Formal languages and automata theory</compound-subject-part>
<compound-subject-part content-type="weight">500</compound-subject-part>
</compound-subject>
<compound-subject>
<compound-subject-part content-type="code">10003752.10003766.10003776</compound-subject-part>
<compound-subject-part content-type="text">Theory of computation~Regular languages</compound-subject-part>
<compound-subject-part content-type="weight">500</compound-subject-part>
</compound-subject>
<compound-subject>
<compound-subject-part content-type="code">10011007.10011006.10011039.10011311</compound-subject-part>
<compound-subject-part content-type="text">Software and its engineering~Semantics</compound-subject-part>
<compound-subject-part content-type="weight">300</compound-subject-part>
</compound-subject>
</subj-group>
</article-categories>
<title-group>
<article-title>The Simple Essence of Boolean-Algebraic Subtyping</article-title>
<subtitle>Semantic Soundness for Algebraic Union, Intersection, Negation, and Equi-recursive Types</subtitle>
</title-group>
<contrib-group>
<contrib contrib-type="author" id="artseq-001">
<contrib-id contrib-id-type="orcid">0000-0003-0323-6644</contrib-id>
<name>
<surname>Chau</surname>
<given-names>Chun Yin</given-names>
</name>
<aff>Hong Kong University of Science and Technology, Hong Kong, Hong Kong</aff>
<email>cychauab@connect.ust.hk</email>
<role>Author</role>
</contrib>
<contrib contrib-type="author" id="artseq-002">
<contrib-id contrib-id-type="orcid">0000-0002-8805-0728</contrib-id>
<name>
<surname>Parreaux</surname>
<given-names>Lionel</given-names>
</name>
<aff>Hong Kong University of Science and Technology, Hong Kong, Hong Kong</aff>
<email>parreaux@cse.ust.hk</email>
<role>Author</role>
</contrib>
</contrib-group>
<pub-date date-type="publication" pub-type="ppub">
<month>07</month>
<year>2025</year>
</pub-date>
<volume>10</volume>
<issue>POPL</issue>
<history>
<date date-type="received">
<day>10</day>
<month>07</month>
<year>2025</year>
</date>
<date date-type="accepted">
<day>06</day>
<month>11</month>
<year>2025</year>
</date>
</history>
<permissions>
<copyright-year>2025</copyright-year>
<copyright-holder>Copyright held by the owner/author(s)</copyright-holder>
<license license-type="cc by">
<license-p>This work is licensed under a Creative Commons Attribution International 4.0 License.</license-p>
</license>
<license license-type="open-access">
<license-p/>
</license>
</permissions>
<abstract>
<p>Boolean-algebraic subtyping (BAS) is a powerful subtyping approach introduced in 2022 as the &#x201C;secret sauce&#x201D; enabling backtracking-free principal type inference in the MLstruct research language, a structurally-typed functional programming language with tagged records, tag and record subtyping, and tag-based pattern matching. By supporting distributive intersection, union, negation, and equi-recursive types, MLstruct can express powerful programming patterns, such as subtyped extensible variants, without needing row variables. But the use of atypical subtyping rules that violate some interpretations of intersection and union types, the mutual distributivity between these types, and the complexity of coinductive reasoning for equi-recursive types have collectively made the study of BAS difficult. The syntactic soundness proofs provided in the original work are dauntingly complicated and long-winded, obscuring the intuitions behind the correctness of BAS.</p>
<p>In this paper, we distill the simple essence of Boolean-algebraic subtyping: we discover that BAS can be understood through five families of characteristic Boolean homomorphisms defined on types in context. Two of these map to power sets of simpler objects; the rest map back to types, but under an unguarded coinductive assumptions context. Together, these homomorphisms let us prove rather directly that BAS is sound, in that it does not relate constructors of incompatible runtime shapes. These homomorphisms are characteristic in the sense that they are sufficient to capture the meaning of subyping: we prove that if an inequality holds between two types under all these homomorphisms, then subtyping holds between the two types in the original context. This directly suggests a new subtyping decision procedure for BAS, which avoids some inefficiencies in the original algorithm, although it still has exponential worst-case time complexity. We prove that the subtyping problem is in fact co-NP-hard even without recursive types. Finally, we discover that BAS is already powerful enough to encode the removal of a field from a type. This allows us to support extensible records through one new term form and one new typing rule, but, perhaps surprisingly, no changes to subtyping at all.</p>
<p>Our new approach to the semantics of BAS sheds some light on the core of MLstruct&#x2019;s type system. It could be adapted to other languages with algebraic flavors of subtyping, such as Scala 3 and Ceylon, making their design and verification more approachable. Tellingly, all our subtyping soundness proofs fit inside the main body of this paper, with only some administrative lemmas relegated to the appendix.</p>
</abstract>
<kwd-group kwd-group-type="author">
<kwd>subtyping</kwd>
<kwd>Boolean algebra</kwd>
<kwd>extensible records</kwd>
<kwd>structural types</kwd>
</kwd-group>
<custom-meta-group>
<custom-meta>
<meta-name>rightslink</meta-name>
<meta-value>excluded</meta-value>
</custom-meta>
</custom-meta-group>
</article-meta>
</front>
<body>
<sec id="sec-1">
<label>1</label>
<title>Introduction</title>
<p>In 2022, Parreaux and Chau [2022b] presented <italic>MLstruct</italic>, a type system with Boolean-algebraic types (i.e., union, intersection, and negation types), equi-recursive types, tagged records, record subtyping, single inheritance between tags, tag-based pattern matching, and principal type inference. MLstruct built on Simple-sub [Parreaux 2020], a reformulation of MLsub, from the original <italic>algebraic subtyping</italic> approach of Dolan [2017]; Dolan and Mycroft [2017].</p>
<p>Consider the following MLstruct example function<xref ref-type="fn" id="fn1"><sup>1</sup></xref>, where <monospace>Some</monospace> is a user-defined tag:</p>
<fig position="anchor" id="unfig(sequence)">
<graphic xlink:href="3776689_fig01.svg"/>
</fig>
<p>This function has the following inferred type, where unions <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\sqcup$]]></texMath></inlineMaths> bind less strongly than intersections <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\sqcap$]]></texMath></inlineMaths>, and where Obj is the &#x201C;base tag&#x201D; representing all objects that can be pattern matched:</p>
<disp-formula><mml:math display='block'><mml:mtext>&#x00A0;mapSome&#x00A0;</mml:mtext><mml:mo>:</mml:mo><mml:mi mathvariant="normal">&#x2200;</mml:mi><mml:mi>&#x03B1;</mml:mi><mml:mo>,</mml:mo><mml:mi>&#x03B2;</mml:mi><mml:mo>.</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>&#x03B1;</mml:mi><mml:mo stretchy="false">&#x2192;</mml:mo><mml:mi>&#x03B2;</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">&#x2192;</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi mathvariant="normal">#</mml:mi><mml:mtext>&#x00A0;Some&#x00A0;</mml:mtext><mml:mo>&#x2293;</mml:mo><mml:mo fence="false" stretchy="false">{</mml:mo><mml:mtext>&#x00A0;value&#x00A0;</mml:mtext><mml:mo>:</mml:mo><mml:mi>&#x03B1;</mml:mi><mml:mo fence="false" stretchy="false">}</mml:mo><mml:mo>&#x2294;</mml:mo><mml:mi>&#x03B2;</mml:mi><mml:mo>&#x2293;</mml:mo><mml:mi mathvariant="normal">&#x00AC;</mml:mi><mml:mi mathvariant="normal">#</mml:mi><mml:mtext>&#x00A0;Some&#x00A0;</mml:mtext><mml:mo>&#x2293;</mml:mo><mml:mi mathvariant="normal">#</mml:mi><mml:mtext>&#x00A0;Obj&#x00A0;</mml:mtext><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">&#x2192;</mml:mo><mml:mi>&#x03B2;</mml:mi></mml:math></disp-formula>
<p>The type specifies that <monospace>mapSome</monospace> takes as first argument a function taking <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\alpha$]]></texMath></inlineMaths> to <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\be$]]></texMath></inlineMaths> and as second argument <italic>either</italic> an instance of <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathsf{Some}$]]></texMath></inlineMaths><xref ref-type="fn" id="fn2"><sup>2</sup></xref> (i.e., a value of type <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathsf{Some}$]]></texMath></inlineMaths>) that has a field <monospace>value</monospace> of type <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\alpha$]]></texMath></inlineMaths> <italic>or</italic> a value of type <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\be$]]></texMath></inlineMaths> that is <italic>not</italic> an instance of <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathsf{Some}$]]></texMath></inlineMaths>; and that <monospace>mapSome</monospace> returns a value of type <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\be$]]></texMath></inlineMaths>.</p>
<p>The above exemplifies that MLstruct can express extensible variants, a feature found in, e.g., OCaml, which calls them <italic>polymorphic variants</italic> [Garrigue 1998]<xref ref-type="fn" id="fn3"><sup>3</sup></xref>. In fact, MLstruct is significantly more flexible [Parreaux and Chau 2022b] than OCaml thanks to subtyping, which allows flow-sensitive type narrowing, typing conditional branches at different types (taking their union as a result), and implicitly widening types when necessary, which in ML/OCaml-style would require explicit coercions. To the best of our knowledge, MLstruct was also the first type system with unions and intersections that achieved principal type inference. Moreover, it did so without backtracking, and while inferring relatively compact types. The key ingredients in achieving these goals were:
<list list-type="bullet">
<list-item><p>an <italic>algebraic</italic> understanding of types, which allowed the following simplifying rules to be used, which are nonstandard and do not normally hold, except for the last one, when viewing intersection and union types either as intersections and unions of some underlying denotations (such as sets of values [Frisch et al. 2002]) or as obligations in a coercive understanding of subtyping (as in, e.g., the work of Pierce [1991]):
<disp-formula id="eqn1"><label>(1)</label><mml:math display='block'><mml:mtable columnalign="right left left" columnspacing="1em" rowspacing="4pt"><mml:mtr><mml:mtd><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi>&#x03C4;</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">&#x2192;</mml:mo><mml:msub><mml:mi>&#x03C4;</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mo>&#x2293;</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi>&#x03C0;</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">&#x2192;</mml:mo><mml:msub><mml:mi>&#x03C0;</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mo>&#x2261;</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi>&#x03C4;</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>&#x2294;</mml:mo><mml:msub><mml:mi>&#x03C0;</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mo stretchy="false">&#x2192;</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi>&#x03C4;</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>&#x2293;</mml:mo><mml:msub><mml:mi>&#x03C0;</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:mrow></mml:mtd><mml:mtd></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula>
<disp-formula id="eqn2"><label>(2)</label><mml:math display='block'><mml:mtable columnalign="right left left" columnspacing="1em" rowspacing="4pt"><mml:mtr><mml:mtd><mml:mo fence="false" stretchy="false">{</mml:mo><mml:mi>a</mml:mi><mml:mo>:</mml:mo><mml:mi>&#x03C4;</mml:mi><mml:mo fence="false" stretchy="false">}</mml:mo><mml:mo>&#x2294;</mml:mo><mml:mo fence="false" stretchy="false">{</mml:mo><mml:mi>b</mml:mi><mml:mo>:</mml:mo><mml:mi>&#x03C0;</mml:mi><mml:mo fence="false" stretchy="false">}</mml:mo></mml:mtd><mml:mtd><mml:mo>&#x2261;</mml:mo><mml:mi mathvariant="normal">&#x22A4;</mml:mi></mml:mtd><mml:mtd><mml:mtext>&#x00A0;when&#x00A0;</mml:mtext><mml:mi>a</mml:mi><mml:mo>&#x2260;</mml:mo><mml:mi>b</mml:mi></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula>
<disp-formula id="eqn3"><label>(3)</label><mml:math display='block'><mml:mtable columnalign="right left left" columnspacing="1em" rowspacing="4pt"><mml:mtr><mml:mtd><mml:mo fence="false" stretchy="false">{</mml:mo><mml:mi>a</mml:mi><mml:mo>:</mml:mo><mml:mi>&#x03C4;</mml:mi><mml:mo fence="false" stretchy="false">}</mml:mo><mml:mo>&#x2294;</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi>&#x03C0;</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">&#x2192;</mml:mo><mml:msub><mml:mi>&#x03C0;</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mo>&#x2261;</mml:mo><mml:mi mathvariant="normal">&#x22A4;</mml:mi></mml:mtd><mml:mtd></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula>
<disp-formula id="eqn4"><label>(4)</label><mml:math display='block'><mml:mtable columnalign="right left left" columnspacing="1em" rowspacing="4pt"><mml:mtr><mml:mtd><mml:mi mathvariant="normal">#</mml:mi><mml:mi>T</mml:mi><mml:mo>&#x2293;</mml:mo><mml:mi mathvariant="normal">#</mml:mi><mml:mi>S</mml:mi></mml:mtd><mml:mtd><mml:mo>&#x2261;&#x22A5;</mml:mo></mml:mtd><mml:mtd><mml:mtext>&#x00A0;when tags&#x00A0;</mml:mtext><mml:mi>T</mml:mi><mml:mtext>&#x00A0;and&#x00A0;</mml:mtext><mml:mi>S</mml:mi><mml:mtext>&#x00A0;are unrelated&#x00A0;</mml:mtext></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula>
</p></list-item>
<list-item><p>the use of <italic>negations</italic> to transform constraints containing type variables at the top level into bounds, allowing the simplification of arbitrary constraints.</p></list-item>
</list></p>
<p>The subtyping relationships above follow naturally from an <italic>algebraic</italic> understanding of types, where <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\sqcup$]]></texMath></inlineMaths> and <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\sqcap$]]></texMath></inlineMaths> represent respectively the join and meet operations of a particular underlying lattice. Subtyping systems with (1) date back at least to the work of Pottier [1998] and later Dolan [2017]. In these works, the <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\sqcup$]]></texMath></inlineMaths> and <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\sqcap$]]></texMath></inlineMaths> connectives were not referred to as union and intersection, but modern programming languages like Scala and Ceylon have adopted the &#x201C;union&#x201D; and &#x201C;intersection&#x201D; terminology for types that do follow some of these laws: Scala 3&#x2019;s function types satisfy (1), while Ceylon&#x2019;s class types satisfy (4). Rules (2) and (3) are more unusual, but can be understood similarly.</p>
<p>There are two main justifications for including these rules in a language like MLstruct, Scala, or Ceylon. The <italic>philosophical</italic> justification is that a type like <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\{\,a: \tau\,\} \sqcup \{\,b: \pi\,\}$]]></texMath></inlineMaths> does not embed any meaningful information that could be used in programs when <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$a \neq b$]]></texMath></inlineMaths>, as the language can only match on <italic>tags</italic>, not on records themselves, so it cannot tease these two record types apart. Therefore, we can equate such types to <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\top$]]></texMath></inlineMaths>. Similarly, <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\textit{T} \sqcap \textit{S}$]]></texMath></inlineMaths> is uninhabited when <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T$]]></texMath></inlineMaths> and <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$S$]]></texMath></inlineMaths> are unrelated, as no value can have both tags at the same time, so we can equate such types to <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\bot$]]></texMath></inlineMaths>. The <italic>practical</italic> justification is that adding these rules has a dramatic simplifying effect on  subtype constraint solving, helps infer compact type expressions rather than unwieldy sets of constraints, and generally keeps the expressiveness of the subtyping system low enough to avoid backtracking in type inference while retaining complete and principal type inference. Moreover, all these type forms are meaningful and do occur in practice, so we cannot simply rule them out as ill-formed: <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\{\,a: \tau\,\} \sqcup \{\,b: \pi\,\}$]]></texMath></inlineMaths> may arise from taking the least upper bound of two branch of a conditional expression; <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\textit{T} \sqcap \textit{S}$]]></texMath></inlineMaths> may arise from tag-based pattern matching; and function type intersections may arise from extruding rigid type variables with multiple upper bounds [Gao and Parreaux 2025] or, perhaps more importantly, from checking an implementation against multiple inherited signatures. To understand the latter, consider that in Scala, a class can implement multiple traits that each specify a different signature for the same required member. The class must therefore produce an implementation of the member whose type is the intersection of all these signatures. When these signatures are function types, rule (1) allows merging them (without losing precision) into a single function type that can then be used to type check the implementation bidirectionally. Conversely, when the type of a value is an intersection of trait types, a common pattern in Scala, accessing such member yields a value whose type is in positive position and is the intersection of all signatures of the member in each trait.</p>
<p>However, while rules (1)&#x2013;(4) make sense and are useful in practice, they are difficult to justify formally, as they derail the usual techniques for proving subtyping soundness. Tellingly, the Scala 3 bug tracker has had a long-standing open issue<xref ref-type="fn" id="fn4"><sup>4</sup></xref> asking how unions and intersections should distribute over type constructors like function arrows, specifically mentioning that Scala 3 currently implements rule (1) for practical reasons but does not have a known theoretical justification for doing so. Our work provides a first step towards filling the gap by showing how such rules can be formally justified through a Boolean-algebraic subtyping theory.</p>
<p>We show that the semantics of  Boolean-algebraic subtyping (BAS) can be fully characterized by a set of five families of Boolean homomorphisms, which we call <italic>characteristic</italic>. These homomorphisms are enough to semantically justify the soundness of Boolean-algebraic subtyping, leveraging the fact that whenever <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau =< \pi$]]></texMath></inlineMaths> holds, then <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$[|\tau|]=<[|\pi|]$]]></texMath></inlineMaths> holds as well for each homomorphism. We also show a completeness result providing the other side of the characterization: as long as <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$[|\tau|]=<[|\pi|]$]]></texMath></inlineMaths> holds under all characteristic homomorphisms, then we can show that <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau =< \pi$]]></texMath></inlineMaths> also holds.<xref ref-type="fn" id="fn5"><sup>5</sup></xref></p>
<p>Another key insight that allowed us to simplify our reasoning was to reconsider the meaning of <italic>consistent subtyping contexts</italic>: the classical definition relies on the existence of a substitution that makes all inequalities in the context hold, but we show that for the kind of coinductive reasoning on types that we require, it is enough to consider a pseudo-substitution that only substitutes variables <italic>on the outside</italic> of concrete type constructors, without substituting anything inside of them.</p>
<p>The proof of subtyping soundness of MLstruct, which took over 50 pages in the original work, can be reformulated based on these insights so that it fits in the main body of this paper, with only administrative lemmas left to the appendix.</p>
<p>Our contributions are as follows:
<list list-type="bullet">
<list-item><label>&#x2022;</label><p>In Section 2, we present MLstruct<sup>+</sup>, a slight simplification and extension of MLstruct, and we present its Boolean-algebraic subtyping system. We also show that</p>
<list list-type="simple">
<list-item><label>&#x2212;</label><p>unexpectedly, Eq. (2) above (i.e., the S-R<sc>cd</sc>T<sc>op</sc>} subtyping rule)  does more than just simplify subtyping:  it is the key to letting us define a notion of <italic>field removal</italic> in types; and</p></list-item><list-item><label>&#x2212;</label><p>this can be leveraged to define extensible records, the dual to extensible variants, through a modest modifications to the terms and typing rules of MLstruct.</p></list-item>
<list-item><label>&#x2212;</label><p>In Section 3, we present our new notion of subtyping context consistency, another important ingredient in the simplification of the metatheory of  BAS and MLstruct.</p></list-item><list-item><label>&#x2022;</label><p>In Section 4, we present a simple semantic proof of subtyping soundness based on the five families of characteristic homomorphisms of Boolean-algebraic subtyping.</p></list-item><list-item><label>&#x2022;</label><p>In Section 5, we prove that the presented homomorphisms are indeed <italic>characteristic</italic>. We also show that while this suggests a new subtyping decision procedure, the subtyping problem is in fact co-NP-hard, even without recursive types.</p></list-item>
</list></list-item></list></p>
</sec>
<sec id="sec-2">
<label>2</label>
<title>Presentation of MLstruct<sup>+</sup> and Boolean-Algebraic Subtyping</title>
<p>In this section, we describe MLstruct<sup>+</sup>, a slight variation on the original MLstruct language, and explain its Boolean-algebraic subtyping system.</p>
<sec id="sec-2_1">
<label>2.1</label>
<title>MLstruct<sup>+</sup> Primer</title>
<p>MLstruct<sup>+</sup> is a research language based on MLstruct [Parreaux and Chau 2022a]. Like MLstruct, MLstruct<sup>+</sup> features lambda abstractions, tagged records, tag and record subtyping, and tag-based pattern matching. Tagged records are written as, e.g., <monospace>Some { value = 42 }</monospace>, where <monospace>Some</monospace> is the tag and <monospace>value</monospace> is a field name. (We also assume the existence of base types like <monospace>Int</monospace> and <monospace>Bool</monospace>, which are easily encoded.) Due to tag subtyping, the <monospace>Some</monospace> tag may be a subtype of a more general tag, say <monospace>Option</monospace>, where unlike traditional ML-family languages, the <monospace>Option</monospace> tag can also be pattern matched. The pattern matching construct of MLstruct<sup>+</sup> has syntax <monospace>if x is C then t else e</monospace>, where <monospace>C</monospace> is a tag (e.g., <monospace>Some</monospace>, <monospace>Option</monospace>).<xref ref-type="fn" id="fn6"><sup>6</sup></xref> MLstruct<sup>+</sup> features <italic>flow-sensitive typing</italic>: if the scrutinee variable <monospace>x</monospace> is initially assigned type <monospace>T</monospace>, then that type is <italic>refined</italic> (or <italic>narrowed</italic>) in the <monospace>then</monospace> branch to <monospace>T &#x0026; #C</monospace> (meaning <monospace>x</monospace> has <italic>both</italic> types <monospace>T</monospace> <italic>and</italic> <monospace>#C</monospace>) and in the <monospace>else</monospace> branch to <monospace>T &#x0026; ~#C</monospace> (<monospace>x</monospace> has types <monospace>T</monospace> <italic>and</italic> <monospace>~#C</monospace>, i.e., <monospace>x</monospace> is not of tag <monospace>C</monospace>). MLstruct<sup>+</sup> can assign to a pattern matching expression the union of the types of its branches, so for example <monospace>if</monospace> &#x2026; <monospace>then Foo{} else Bar{}</monospace> has type <monospace>#Foo | #Bar</monospace> (i.e., it can be a <monospace>#Foo</monospace> or a <monospace>#Bar</monospace>). Dually, intersection types can be used to type multiple uses of a variable; for example, <disp-formula><mml:math display='block'><mml:mtext>def&#x00A0;</mml:mtext><mml:mi>f</mml:mi><mml:mi>x</mml:mi><mml:mo>=</mml:mo><mml:mtext>if&#x00A0;</mml:mtext><mml:mi>x</mml:mi>.<mml:mtext>fst is True then x.fst else x.snd</mml:mtext></mml:math></disp-formula> has type <monospace>f : ({ fst</monospace>: <monospace>altv &#x0026; (#True | ~#True &#x0026; #Obj) } &#x0026; { snd</monospace>: <monospace>betv }) &#x2192; (altv | betv)</monospace>. Finally, MLstruct<sup>+</sup> supports implicit <italic>subsumption</italic> (or <italic>widening</italic>), meaning that no explicit coercions are needed between a type and its supertypes: the type checker is always able to insert them automatically in a principal way, i.e., without losing any information. This is what allows calling <monospace>f</monospace> above with a value <monospace>arg</monospace> of type, e.g., <monospace>#Pair &#x0026; { fst</monospace>: <monospace>#True | #False, snd</monospace>: <monospace>String }</monospace>, as in <monospace>f arg</monospace>, yielding a result type of <monospace>#True | String</monospace>. By contrast, in a language like OCaml, which does have (a limited form of) subtyping but does not support implicit subsumption, explicit coercions would be required to transform an <monospace>arg</monospace> of the equivalent type just to convince the type checker that <monospace>arg</monospace> is indeed a valid argument to <monospace>f</monospace>.</p>
<sec id="sec-2_1_1">
<label>2.1.1</label>
<title>Expressiveness</title>
<p>Exhaustive pattern matching can be <italic>encoded</italic>: a pattern matching expression of the form <monospace>if</monospace> x is C<sub>1</sub> <monospace>then</monospace> e<sub>1</sub><monospace>,</monospace> <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\cdots$]]></texMath></inlineMaths><monospace>,</monospace> <monospace>C</monospace><sub>n</sub> <monospace>then</monospace> e<sub>n</sub> can be encoded as <monospace>if</monospace> x is C<sub>1</sub> <monospace>then</monospace> e<sub>1</sub> <monospace>else</monospace> <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\cdots$]]></texMath></inlineMaths> <monospace>if</monospace> x is C<sub>n</sub> <monospace>then</monospace> e<sub>n</sub> <monospace>else</monospace> <monospace>x : bott</monospace>, where the last default branch expression <monospace>x : bott</monospace> effectively asserts that the last case is unreachable by forcing the scrutinee in that case to be of the uninhabited bottom type, making the type checker statically ensure that all cases are handled (a pattern also found in TypeScript, though without a syntax sugar). For a larger example illustrating the expressiveness of MLstruct<sup>+</sup>&#x2019;s type system, one may refer to them, one may refer to the <monospace>flatten</monospace> function given in Appendix~\ref{app:example:flatten}, which flattens its parameter recursively when it is a list and otherwise leaves it unchanged.
<fig id="fig-1" orientation="portrait" position="float">
<label>Fig. 1.</label>
<caption><p>Syntax of MLstruct <inline-formula><mml:math display='inline'><mml:msup><mml:mrow></mml:mrow><mml:mrow><mml:mo>+</mml:mo></mml:mrow></mml:msup></mml:math></inline-formula>.</p></caption>
<graphic xlink:href="Fig-1.tif">
<alt-text></alt-text>
</graphic>
</fig></p></sec>
<sec id="sec">
<label>2.1.2</label>
<title>Type Simplification and Compactness</title>
<p>A major advantage of the subtyping relations (1)&#x2014;(4) mentioned in Section 1 is that it allows simplifying types aggressively by merging unions and intersections when doing so does not entail a loss of information, which results in the inference of compact type representations that can then be printed back to the user. For instance, without simplification, <monospace>fun f &#x2192; if</monospace> &#x2026; <monospace>then f True{} else f False{}</monospace> would have inferred type <monospace>((#True &#x2192; altv) &#x0026; (#False &#x2192; betv)) &#x2192; (altv | betv)</monospace>, but with simplifications notably based on rule~(1) this can be reduced to just <monospace>((#True | #False) &#x2192; gatv) &#x2192; gatv</monospace>. Similarly, a conditional expression returning a value of type <monospace>{ payload: S, a: T }</monospace> in one branch and <monospace>{ payload: U, b: V }</monospace> in the other can be simplified thanks to rule~(2) to just <monospace>{ payload: S | U }</monospace> [Parreaux and Chau 2022b, ยง2.3.2].</p>
</sec>
<sec id="sec">
<label>2.1.3</label>
<title>Extension</title>
<p>MLstruct<sup>+</sup> features one significant addition over MLstruct: its support for record extension, with syntax <monospace>C { ...s, a = t }</monospace>, which extends a <monospace>C</monospace>-tagged record <monospace>s</monospace> with a field <monospace>a</monospace> of value <monospace>t</monospace>, where if <monospace>a</monospace> is already present in <monospace>s</monospace>, it is replaced in the resulting record. The syntax requires <monospace>C</monospace> to be provided explicitly so that type checking can be syntax-directed. As a shorthand, plain record literal terms of the form <monospace>{ ... }</monospace> are understood as having tag <monospace>Obj</monospace>, i.e., to mean <monospace>Obj { ... }</monospace>.</p>
</sec>
</sec>
<sec id="sec">
<label>2.2</label>
<title>Formal Syntax of MLstruct<sup>+</sup></title>
<sec id="sec">
<title>Notations</title>
<p>We use the notation <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\overline{E}^{x \in S}$]]></texMath></inlineMaths> to denote a repetition of <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$|S|$]]></texMath></inlineMaths> occurrences of a syntax form <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$E$]]></texMath></inlineMaths> (wherein <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$x$]]></texMath></inlineMaths> is free) for each <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$x$]]></texMath></inlineMaths> taken from collection <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$S$]]></texMath></inlineMaths>. When <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$S$]]></texMath></inlineMaths> is omitted for brevity, all repetitions using the same <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$x$]]></texMath></inlineMaths> are understood to share the same <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$S$]]></texMath></inlineMaths>; e.g., <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\overline{A_x}^x\,\overline{B_x}^x$]]></texMath></inlineMaths> means <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\overline{A_x}^{x \in S}\,\overline{B_x}^{x \in S}$]]></texMath></inlineMaths> for some <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$S$]]></texMath></inlineMaths>.</p></sec>
<sec id="sec">
<label>2.2.1</label>
<title>Syntax</title>
<p>The syntax of MLstruct<sup>+</sup> is presented in Fig. 1. To avoid repetition in our rules and metatheory, we use a <italic>polarity</italic> notations <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\pm$]]></texMath></inlineMaths> and <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\diamond$]]></texMath></inlineMaths> to treat <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\top/\bot$]]></texMath></inlineMaths>, <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\sqcup/\sqcap$]]></texMath></inlineMaths>, and <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\le/\ge$]]></texMath></inlineMaths> symmetrically [Oliveira et al. 2020; Parreaux and Chau 2022a]. For example, <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\top^{+}$]]></texMath></inlineMaths> is <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\top$]]></texMath></inlineMaths>, while <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\top^{-}$]]></texMath></inlineMaths> is <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\bot$]]></texMath></inlineMaths>.</p>
</sec>
<sec id="sec">
<label>2.2.2</label>
<title>Objects and Tags</title>
<p>Conceptually, an object <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T\,\{\,a_1=v_1 ** a_2=v_2 ** \cdots\,\}$]]></texMath></inlineMaths> is made of a <italic>tag</italic> <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T$]]></texMath></inlineMaths> and a set of <italic>fields</italic> <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\{\,a_1=v_1 ** a_2=v_2 ** \cdots\,\}$]]></texMath></inlineMaths>; its type is <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\textit{T} \sqcap \{\,a_1:\tau_1\,\} \sqcap \{\,a_2:\tau_2\,\} \sqcap \cdots$]]></texMath></inlineMaths> when <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$v_1:\tau_1$]]></texMath></inlineMaths>, <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$v_2:\tau_2$]]></texMath></inlineMaths>, etc., using an intersection of single-field record types (<italic>field types</italic>) like in the Forsythe language [Reynolds 1997]. Concretely, object literals are encoded using compositions of the empty object at tag <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T$]]></texMath></inlineMaths>, written <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T\, \{\}$]]></texMath></inlineMaths>, and field extensions at tag <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T$]]></texMath></inlineMaths>, written <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\rcdExt\Clss{a=t}$]]></texMath></inlineMaths>. Traditional extensible records, which are <italic>untagged</italic>, can be thought of as records using some distinguished tag <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T_{\text{rcd}}$]]></texMath></inlineMaths>. A tag <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T$]]></texMath></inlineMaths> may be related to another tag <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$S$]]></texMath></inlineMaths> through a <italic>tag single-inheritance</italic> relation. We write <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T \preceq S$]]></texMath></inlineMaths> to denote that <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T$]]></texMath></inlineMaths> inherits transitively from <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$S$]]></texMath></inlineMaths>. By convention, all tags inherit from some distinguished tag conventionally denoted as Obj (i.e., <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\forallT.\, T \preceq \mtext{Obj}$]]></texMath></inlineMaths>), so the directed graph of tag inheritance forms a tree<xref ref-type="fn" id="fn7"><sup>7</sup></xref>, Note that the tag inheritance relation is reflexive. Moreover, when <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T$]]></texMath></inlineMaths> transitively inherits from <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$S$]]></texMath></inlineMaths>, this induces a subtyping relation <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T \leq S$]]></texMath></inlineMaths>. We also encode primitive types like <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tyCtor{Bool$]]></texMath></inlineMaths> and <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tyCtor{Int$]]></texMath></inlineMaths> as tags. Field types <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\{\,a:\tau\,\}$]]></texMath></inlineMaths> are related by the usual depth subtyping, while the traditional width subtyping of record types arises from the representation of record types as intersection of field types.</p>
</sec>
<sec id="sec">
<label>2.2.3</label>
<title>Polymorphism</title>
<p>Parametric polymorphism in MLstruct<sup>+</sup> is attached solely to top-level &#x2018;<inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\textbf{\textsf{def}}$]]></texMath></inlineMaths>&#x2019; bindings, whose semantics, as in languages like Scala, is to re-evaluate their right-hand side every time they are referred to in the program. In contrast, local let bindings are desugared to immediately-applied lambdas, and are treated monomorphically. <italic>Let polymorphism</italic> is orthogonal to the features presented in this paper, and can be handled by using a level-based algorithm [Parreaux 2020] on top of the core algorithm we describe here or through an equivalent of lambda lifting, along with the usual value restriction if the language is meant to incorporate mutation.</p>
</sec>
<sec id="sec">
<label>2.2.4</label>
<title>Recursion</title>
<p>In MLstruct<sup>+</sup>, <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\textbf{\textsf{def}}$]]></texMath></inlineMaths> bindings are not recursive. This simplification is made without loss of generality, as recursion can be recovered using a Z fixed point combinator, typeable in MLstruct [Parreaux and Chau 2022b] and thus also in MLstruct<sup>+</sup>.</p></sec>
<sec id="sec">
<label>2.2.5</label>
<title>Encoding of Recursive Data Types</title>
<p>The original presentation of MLstruct included <italic>type alias definitions</italic> and <italic>class definitions</italic>. A type alias use was treated as equivalent to its body after type argument substitution (the subtyping rules could expand them on the fly). On the other hand, a class type use was equivalent to the substituted body of the class (a record type) <italic>intersected</italic> with a &#x201C;class tag&#x201D; denoting the object&#x2019;s runtime class. In this paper, we boil this all down to its essence: we only describe <italic>records</italic> and <italic>tags</italic>, which are sufficient for all intents and purposes. Each use <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$A[{\overline{\pi}}]$]]></texMath></inlineMaths> of an old MLstruct type definition <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$A[{\overline{X}}]$]]></texMath></inlineMaths> can be encoded as a fresh type variable <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\alpha$]]></texMath></inlineMaths> with bounds <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\alpha=<\tau$]]></texMath></inlineMaths> and <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau=<\alpha$]]></texMath></inlineMaths>, where <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau$]]></texMath></inlineMaths> is the deeply expanded body of <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$A$]]></texMath></inlineMaths> (up until its recursive occurrences), in which each <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$X$]]></texMath></inlineMaths> is replaced by a fresh <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\be$]]></texMath></inlineMaths> with bounds <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\be=<\pi$]]></texMath></inlineMaths> and <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\pi=<\be$]]></texMath></inlineMaths>. Because the types are regular, this approach is fully general. The equi-bounded type variables <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\be$]]></texMath></inlineMaths> avoid syntactic substitutions and lead to better worst-case complexity of subtype checking: they make the MLscript constraint solver behave like QuickSub [Zhou and Oliveira 2025] when specialized to iso-recursive use cases.</p></sec>
<sec id="sec">
<label>2.2.6</label>
<title>Contexts</title>
<p>We use three kinds of contexts. Typing contexts <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\Gamma$]]></texMath></inlineMaths> bind both <italic>monomorphic</italic> and <italic>polymorphic</italic> types to variables, the latter corresponding to &#x2018;<inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\textbf{\textsf{def}}$]]></texMath></inlineMaths>&#x2019; bindings. Subtyping contexts <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\Sigma$]]></texMath></inlineMaths> record assumptions about subtyping relationships, with some of these assumptions potentially hidden behind a &#x25B7; (explained in Section 2.5.1. Finally, <italic>bounds</italic> contexts <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{B}$]]></texMath></inlineMaths> contain bounds on type variables. The typing rules will ensure that in a polymorphic type <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\fa\mathcal{B.\,\tau$]]></texMath></inlineMaths>, context <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{B}$]]></texMath></inlineMaths> is <italic>consistent</italic>.</p></sec>
<sec id="sec">
<label>2.2.7</label>
<title>Shorthands</title>
<p>Throughout this paper, we make use of the following notations and shorthands:</p>
<disp-formula id="eqn"><label></label><mml:math display='block'><mml:mtable displaystyle="true" columnspacing="1em" rowspacing="3pt" name="gathered"><mml:mtr><mml:mtd><mml:mi>T</mml:mi><mml:mrow><mml:mo>}</mml:mo><mml:mo>&#x225C;</mml:mo><mml:mi mathvariant="normal">#</mml:mi><mml:mi>T</mml:mi><mml:mstyle scriptlevel="0"><mml:mspace width="1em"></mml:mspace></mml:mstyle><mml:mrow><mml:mo>{</mml:mo><mml:mover><mml:mrow><mml:mi>a</mml:mi><mml:mo>:</mml:mo><mml:msub><mml:mi>&#x03C4;</mml:mi><mml:mrow><mml:mi>a</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo accent="true">&#x2015;</mml:mo></mml:mover><mml:mi>a</mml:mi><mml:mo>&#x2208;</mml:mo><mml:mi>S</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo>:</mml:mo><mml:msub><mml:mi>&#x03C4;</mml:mi><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub><mml:mo>}</mml:mo></mml:mrow><mml:mo>&#x225C;</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mover><mml:mrow><mml:mi>a</mml:mi><mml:mo>:</mml:mo><mml:msub><mml:mi>&#x03C4;</mml:mi><mml:mrow><mml:mi>a</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo accent="true">&#x2015;</mml:mo></mml:mover><mml:msup><mml:mrow></mml:mrow><mml:mrow><mml:mi>a</mml:mi><mml:mo>&#x2208;</mml:mo><mml:mi>S</mml:mi></mml:mrow></mml:msup><mml:mo>}</mml:mo></mml:mrow><mml:mo>&#x2293;</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mi>b</mml:mi><mml:mo>:</mml:mo><mml:msub><mml:mi>&#x03C4;</mml:mi><mml:mrow><mml:mi>b</mml:mi></mml:mrow></mml:msub><mml:mo>}</mml:mo></mml:mrow><mml:mstyle scriptlevel="0"><mml:mspace width="1em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">(</mml:mo><mml:mi>b</mml:mi><mml:mo>&#x2209;</mml:mo><mml:mi>S</mml:mi><mml:mo>,</mml:mo><mml:mi>S</mml:mi><mml:mo>&#x2260;</mml:mo><mml:mi>&#x2205;</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo fence="true" stretchy="true" symmetric="true"></mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mi>T</mml:mi><mml:mo fence="false" stretchy="false">{</mml:mo><mml:mover><mml:mrow><mml:mi>a</mml:mi><mml:mo>:</mml:mo><mml:mi>&#x03C4;</mml:mi></mml:mrow><mml:mo accent="true">&#x2015;</mml:mo></mml:mover><mml:mo fence="false" stretchy="false">}</mml:mo><mml:mo>&#x225C;</mml:mo><mml:mi mathvariant="normal">#</mml:mi><mml:mi>T</mml:mi><mml:mo>&#x2293;</mml:mo><mml:mo fence="false" stretchy="false">{</mml:mo><mml:mover><mml:mrow><mml:mi>a</mml:mi><mml:mo>:</mml:mo><mml:mi>&#x03C4;</mml:mi></mml:mrow><mml:mo accent="true">&#x2015;</mml:mo></mml:mover><mml:mo fence="false" stretchy="false">}</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="1em"></mml:mspace></mml:mstyle><mml:mi>&#x03C4;</mml:mi><mml:mi mathvariant="normal">&#x2216;</mml:mi><mml:mi>a</mml:mi><mml:mo>&#x225C;</mml:mo><mml:mi>&#x03C4;</mml:mi><mml:mo>&#x2294;</mml:mo><mml:mi mathvariant="normal">&#x00AC;</mml:mi><mml:mo fence="false" stretchy="false">{</mml:mo><mml:mi>a</mml:mi><mml:mo>:&#x22A5;</mml:mo><mml:mo fence="false" stretchy="false">}</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="1em"></mml:mspace></mml:mstyle><mml:mi>&#x03C4;</mml:mi><mml:mi mathvariant="normal">&#x2216;</mml:mi><mml:mi mathvariant="normal">#</mml:mi><mml:mi>T</mml:mi><mml:mo>&#x225C;</mml:mo><mml:mi>&#x03C4;</mml:mi><mml:mo>&#x2293;</mml:mo><mml:mi mathvariant="normal">&#x00AC;</mml:mi><mml:mi mathvariant="normal">#</mml:mi><mml:mi>T</mml:mi><mml:mo>&#x2293;</mml:mo><mml:mi mathvariant="normal">#</mml:mi><mml:mtext>&#x00A0;Obj&#x00A0;</mml:mtext></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula>
<p>We will clarify the field and tag removal shorthand definitions in Section 2.6 and Section 2.7.</p>
</sec>
</sec>
<sec id="sec">
<label>2.3</label>
<title>Evaluation Rules of MLstruct<sup>+</sup></title>
<p>The small-step reduction semantics of MLstruct<sup>+</sup> is shown in Fig. 2.. The relation  <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$P ~> P'$]]></texMath></inlineMaths> reads &#x201C; program <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$P$]]></texMath></inlineMaths> evaluates to program <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$P'$]]></texMath></inlineMaths> in one step.&#x201D; Note that <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$P$]]></texMath></inlineMaths> here may refer to a simple term <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$t$]]></texMath></inlineMaths>.</p>
<fig id="fig-2" orientation="portrait" position="float">
<label>Fig. 2.</label>
<caption><p>Small-step evaluation rules.</p></caption>
<graphic xlink:href="Fig-2.tif">
<alt-text></alt-text>
</graphic>
</fig>
</sec>
<sec id="sec">
<label>2.4</label>
<title>Typing Rules MLstruct<sup>+</sup></title>
<p>Fig. 3 shows the <italic>declarative</italic> typing rules of MLstruct<sup>+</sup>\!. These rules are not syntax-directed, as they have to guess some types, for instance the type of a lambda abstraction&#x2019;s parameter or the result type of an <monospace>if</monospace> expression. The algorithmic typing rules of the language would always pick a fresh type variable for the former and a union type for the latter [Parreaux and Chau 2022a].</p>
<fig id="fig-3" orientation="portrait" position="float">
<label>Fig. 3.</label>
<caption><p>Program and term typing rules.</p></caption>
<graphic xlink:href="Fig-3.tif">
<alt-text></alt-text>
</graphic>
</fig>
<p><italic>Program</italic>-typing judgments <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{B},\Gamma |-^\star P : \tau$]]></texMath></inlineMaths> are used to type programs while <italic>term</italic>-typing judgments <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{B},\Gamma |- t : \tau$]]></texMath></inlineMaths> are used to type <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\textbf{\textsf{def}}$]]></texMath></inlineMaths> right-hand sides and program bodies. The latter judgment is read &#x201C;under type variable bounds <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{B}$]]></texMath></inlineMaths> and in context <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\Gamma$]]></texMath></inlineMaths>, term <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$t$]]></texMath></inlineMaths> has type <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau$]]></texMath></inlineMaths>.&#x201D; The consistency judgment (<inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\scons\mathcal{B}$]]></texMath></inlineMaths>), explained later in Section 3.2, is used to make sure we type <monospace>def</monospace>s and program bodies under <italic>valid</italic> (i.e., consistent) bounds only.<xref ref-type="fn" id="fn8"><sup>8</sup></xref></p>
<p>Rule T-B<sc>ody</sc> is used to type programs that happen to be simple terms, after having accumulated a set of definitions in the context.</p>
<p>In T-D<sc>ef</sc>, we type the body of a <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\textbf{\textsf{def}}$]]></texMath></inlineMaths> inside a constraining context <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{B}$]]></texMath></inlineMaths> added on top of the current declarations context, and subsequently use <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{B}$]]></texMath></inlineMaths> as part of the resulting polymorphic type of this <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\textbf{\textsf{def}}$]]></texMath></inlineMaths>, which is placed into the typing context for use later in the program. Importantly, <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{B}$]]></texMath></inlineMaths> has to be checked for consistency, which is done with the <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\scons\mathcal{B}$]]></texMath></inlineMaths> judgment. This is to forbid the use of inconsistent bounds on type variables, such as <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$(\tyCtor{Bool=<\alpha)\ctxPush{\alpha =< \mathsf{Int}$]]></texMath></inlineMaths>, which could lead to accepting ill-typed definitions.</p>
<p>As a concrete example for T-D<sc>ef</sc>, consider a definition such as <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\textbf{\textsf{def}}\ f = \lam x.\ x + 1$]]></texMath></inlineMaths>. One hypothetical judgment used to type this definition could be &#x2018;<inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$(\alpha=<\tyCtor{Int),\Gamma |- \lambda x.\ x + 1 : \alpha &#x2192; \tyCtor{Int$]]></texMath></inlineMaths>&#x2019;, where <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{B} = (\alpha=<\tyCtor{Int)$]]></texMath></inlineMaths> is the constraining context. According to T-D<sc>ef</sc>, because <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{B}$]]></texMath></inlineMaths> is consistent (as witnessed by the top-level substitution <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\setLit{\alpha |&#x2192; \mathsf{Int}^\star$]]></texMath></inlineMaths>, since applying it to <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{B}$]]></texMath></inlineMaths> gives <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$(\tyCtor{Int =< \tyCtor{Int)$]]></texMath></inlineMaths>, a tautology) we can type the definition <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$f$]]></texMath></inlineMaths> as &#x2018;<inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\forall(\alpha=<\tyCtor{Int).\ \alpha &#x2192; \tyCtor{Int$]]></texMath></inlineMaths>&#x2019;. As a side note, this type can be rewritten equivalently to <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$f: \tyCtor{Int &#x2192; \tyCtor{Int$]]></texMath></inlineMaths>.</p>
<p>Rule T-O<sc>bj</sc> is used to instantiate a new object of tag <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T$]]></texMath></inlineMaths>. It requires <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T$]]></texMath></inlineMaths> to be &#x201C;final&#x201D; using the <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\finalT$]]></texMath></inlineMaths> judgment, which means that there exists no tag <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$S$]]></texMath></inlineMaths> such that <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$S \preceq T$]]></texMath></inlineMaths>, i.e., <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T$]]></texMath></inlineMaths> is not extended by any other tag. This ensures that, at runtime, for every tag pattern <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$S$]]></texMath></inlineMaths>, pattern-matching scrutinees are always instances of a tag <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T$]]></texMath></inlineMaths> that is either a subtag of <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$S$]]></texMath></inlineMaths> (meaning <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[${\#}{T} =< \textit{S}$]]></texMath></inlineMaths>) or an unrelated tag (meaning <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[${\#}{T} =< \neg\textit{S}$]]></texMath></inlineMaths>). This is a mere technicality, necessary to make type preservation hold. Any instantiation of a non-final tag <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T$]]></texMath></inlineMaths> can be encoded as an instantiation of a fresh final subtag <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T^{\text{f}}$]]></texMath></inlineMaths> of <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T$]]></texMath></inlineMaths>.</p>
<p>Rule T-E<sc>xt</sc> is used to extend an existing object <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$t_0$]]></texMath></inlineMaths> of tag <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T$]]></texMath></inlineMaths> with with a new value <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$t_1$]]></texMath></inlineMaths> for some field <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$a$]]></texMath></inlineMaths>, written <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\rcdExtT{t_0}{a = t_1}$]]></texMath></inlineMaths>. The first premise ensures that <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$t_0$]]></texMath></inlineMaths> is an object of tag <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T$]]></texMath></inlineMaths> and can be typed as some type <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau_0$]]></texMath></inlineMaths>. The second premise types the new value for field <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$a$]]></texMath></inlineMaths> as some <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau_1$]]></texMath></inlineMaths>. The conclusion states that the extended object can be typed as <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau_0$]]></texMath></inlineMaths> with the field <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$a$]]></texMath></inlineMaths> removed and intersected with the new record field <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$a$]]></texMath></inlineMaths> of type <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau_1$]]></texMath></inlineMaths> and the tag <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\textit{T}$]]></texMath></inlineMaths>, i.e., <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau_0 \fieldminusa\hspace{1pt} \sqcap \{\,a: \tau_1\,\} \sqcap \textit{T}$]]></texMath></inlineMaths>, where <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau_0 \fieldminusa$]]></texMath></inlineMaths> is a shorthand for <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau_0 \sqcup \neg\{\,a: \bot\,\}$]]></texMath></inlineMaths>.</p>
<p>Rule T-P<sc>roj</sc> is used to access a field <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$a$]]></texMath></inlineMaths> of an object <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$t$]]></texMath></inlineMaths>. The premise ensures that <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$t$]]></texMath></inlineMaths> can be typed as <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\{\,a: \tau\,\}$]]></texMath></inlineMaths>. Then the conclusion states that the field <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$a$]]></texMath></inlineMaths> of <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$t$]]></texMath></inlineMaths> has type <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau$]]></texMath></inlineMaths>.</p>
<p>The rule T-A<sc>bs</sc> types a lambda abstraction <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\lambda{x}.\ t$]]></texMath></inlineMaths> by typing its body <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$t$]]></texMath></inlineMaths> as type <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau_2$]]></texMath></inlineMaths> while assuming the parameter <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$x$]]></texMath></inlineMaths> has type <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau_1$]]></texMath></inlineMaths>. The conclusion then states that the lambda abstraction has type <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau_1 &#x2192; \tau_2$]]></texMath></inlineMaths>.</p>
<p>The rule T-A<sc>pp</sc> is used to type an application <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$t_0\ t_1$]]></texMath></inlineMaths> of <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$t_0$]]></texMath></inlineMaths> to the argument <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$t_1$]]></texMath></inlineMaths>. The first premise ensures that <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$t_0$]]></texMath></inlineMaths> is a function that accepts an argument of type <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau_1$]]></texMath></inlineMaths> and returns a result of type <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau_2$]]></texMath></inlineMaths>. The second premise then ensures that the type of the argument matches <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau_1$]]></texMath></inlineMaths>. Then conclusion then states that the result of the application has type <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau_2$]]></texMath></inlineMaths>.</p>
<p>The rule T-A<sc>sc</sc> ascribes the type <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau$]]></texMath></inlineMaths> to the term <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$t$]]></texMath></inlineMaths>. The premise simply ensures that <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$t$]]></texMath></inlineMaths> can indeed be typed as <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau$]]></texMath></inlineMaths>.</p>
<p>In T-S<sc>ubs</sc>, we use the current constraining context <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{B}$]]></texMath></inlineMaths> as a subtyping context <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\Sigma$]]></texMath></inlineMaths> when invoking the subtyping judgment <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{B} |- \tau_1 \leq \tau_2$]]></texMath></inlineMaths> (presented in the next subsection), which is possible since the syntax of constraining contexts is a special case of the syntax of subtyping contexts.</p>
<p>Rule T-V<sc>ar</sc>1 looks up the typing context for a monomorphic binding of a variable.</p>
<p>Rule T-V<sc>ar</sc>2 is an interesting counterpart to rule T-D<sc>ef</sc> explained above. It <italic>instantiates</italic> a given polymorphic type using a substitution <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\rho$]]></texMath></inlineMaths>.</p>
<p>The <italic>entailment</italic> judgment <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{B} |= \rho(\mathcal{A})$]]></texMath></inlineMaths>, makes sure that every subtyping constraint in <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\rho(\mathcal{A})$]]></texMath></inlineMaths> holds in <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{B}$]]></texMath></inlineMaths>. The formal definition of substitutions is straightforward and relegated to \ifdefined\ExcludeApps the appendix\elseAppendix~\ref{app:subst}\fi.</p>
<p>Pattern matching <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\textbf{\textsf{if}}$]]></texMath></inlineMaths> expressions are handled by the rule T-I<sc>f</sc>. Since the this is a declarative type system, the premises of this rule mentions two types <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau_1$]]></texMath></inlineMaths> and <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau_2$]]></texMath></inlineMaths> picked out of thin air, akin to how the type of the parameter is picked in the classical way of typing a lambda abstraction. To type such expressions, we first assume that the scrutinee <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$t_0$]]></texMath></inlineMaths> has some type <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau_1$]]></texMath></inlineMaths> in order to type the matched branch, and then assume <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$t_0$]]></texMath></inlineMaths> has type <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau_2$]]></texMath></inlineMaths> to type the default branch. Then, we make sure that the scrutinee <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$t_0$]]></texMath></inlineMaths> can be typed at <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\textit{T} \sqcap \tau_1 \sqcup \tau_2\tagminusT$]]></texMath></inlineMaths>, where <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau_2\tagminusT$]]></texMath></inlineMaths> is a shorthand for <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau_2 \sqcap \neg\textit{T} \sqcap \mtext{Obj}$]]></texMath></inlineMaths>. This ensures that if <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$t_1$]]></texMath></inlineMaths> is an instance of <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T$]]></texMath></inlineMaths>, then it is also of type <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau_1$]]></texMath></inlineMaths>, and if not, then it is an instance of some other tag that is not a subtag of <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T$]]></texMath></inlineMaths> and of type <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau_2$]]></texMath></inlineMaths>. In this rule, <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau_1$]]></texMath></inlineMaths> can be picked to be anything, so assuming <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\Gamma{\cdot{(x:\tau_1)}}$]]></texMath></inlineMaths> to type <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$t_1$]]></texMath></inlineMaths> is sufficient, and there is no need to assume <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\Gamma{\cdot{(x:\tau_1\sqcap\textit{T})}}$]]></texMath></inlineMaths>. If the matched branch needs <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau_1$]]></texMath></inlineMaths> to be a subtype of <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\textit{T}$]]></texMath></inlineMaths>, we can always pick <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau_1 = \tau_1&#x2019; \sqcap \textit{T}$]]></texMath></inlineMaths>. Notice that the required type for <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$t_1$]]></texMath></inlineMaths> still has the same shape <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\textit{T} \sqcap \tau_1 \sqcup \tau_2\tagminusT \ ==\ \textit{T} \sqcap (\textit{T} \sqcap \tau_1') \sqcup \tau_2\tagminusT  \ ==\ \textit{T} \sqcap \tau_1' \sqcup \tau_2\tagminusT$]]></texMath></inlineMaths>. To express exhaustive pattern matching, we can pick the ascription <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$x: \bot$]]></texMath></inlineMaths> as the default branch, which ensures that the scrutinee must have already been matched by assigning to it type <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\bot$]]></texMath></inlineMaths> (the type inhabited by no values).</p>
<p>The pattern matching syntax and the T-I<sc>f</sc> rule differs from the original MLstruct formulation by nesting expressions matching a single tag with a default branch instead of enumerating branches as a flat list. This allows us to to condense the three typing for the original formulation into one single rule and simplify the soundness proofs.</p>
</sec>
<sec id="sec">
<label>2.5</label>
<title>Boolean-Algebraic Subtyping</title>
<sec id="sec">
<label>2.5.1</label>
<title>Subtyping Recursive Types</title>
<p>A consequence of our syntactic account of subtyping is that we do <italic>not</italic> define types as some fixed point over a generative relation, as done by, e.g., Dolan [2017]; Pierce [2002]. Instead, we have to account for the fact that we manipulate <italic>finite</italic> syntactic type trees, in which recursive types have to be manually unfolded to derive things about them. This is achieved by the S-H<sc>yp</sc> rules, which allows us to substitute a possibly recursive type with its body, which had been encoded as the bounds on a type variable (Section 2.2.5), to expose one layer of its underlying definition. As remarked by Amadio and Cardelli [1993, ยง3.2], to subtype recursive types, it is not enough to simply allow unfolding them a certain number of times. Moreover, in our system, recursive types may <italic>arise</italic> from cyclic type variable constraints (which is important for type inference), and thus not be attached to any explicit recursive binders. Thus, we cannot simply follow Castagna [2012, ยง1.3.4] in admitting a <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mu$]]></texMath></inlineMaths> rule, which would still be insufficient.</p>
<fig id="fig-4" orientation="portrait" position="float">
<label>Fig. 4.</label>
<caption><p>Core subtyping rules of MLstruct<sup>+</sup></p></caption>
<graphic xlink:href="Fig-4.tif">
<alt-text></alt-text>
</graphic>
</fig>
</sec>
<sec id="sec">
<label>2.5.2</label>
<title>Subtyping Hypotheses</title>
<p>We make use of the <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\Sigma$]]></texMath></inlineMaths> environment to store subtyping hypotheses via S-A<sc>ssum</sc>, to be leveraged later using the S-H<sc>yp</sc> rule. We should be careful not to allow the use of a hypothesis right after assuming it, which would obviously make the system unsound (as it could derive any subtyping). In the specification of their constraint solving algorithm, Hosoya et al.
[2005] use two distinct judgments <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$|-$]]></texMath></inlineMaths> and <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$|-'$]]></texMath></inlineMaths> to distinguish from places where the hypotheses can or cannot be used. We take a different, but related approach. Our S-A<sc>ssum</sc> subtyping rule resembles the L&#x00F6;b rule described Appel et al. [2007], which uses the &#x201C;later&#x201D; modality &#x25B7; in order to delay the usability of hypotheses&#x2014;by placing this symbol in front of the hypothesis being assumed, we prevent its immediate usage by S-H<sc>yp</sc>. We eliminate &#x25B7; when passing through a function or record constructor: the dual <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\lhd$]]></texMath></inlineMaths> symbol is used to remove all &#x25B7; from the set of hypotheses, making them available for use by S-H<sc>yp</sc>. These precautions reflect the %
``guardedness&#x201D; restrictions used by Dolan [2017]
\TODOlater{contractivity? check POPL paper on parametric subty}%
and others on recursive types, which prevents usages of <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\alpha$]]></texMath></inlineMaths> that are not guarded by <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$]]></texMath></inlineMaths>&#x2192;<inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$]]></texMath></inlineMaths> or <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\{\,...\,\}$]]></texMath></inlineMaths> in a recursive type <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\recTy\alpha\tau$]]></texMath></inlineMaths>.</p>
</sec>
<sec id="sec">
<label>2.5.3</label>
<title>A Boolean Algebra</title>
<p>The first two lines of the subtyping rules in Fig. 4, which we call the <italic>pure Boolean-algebraic rules</italic>, give rise to a Boolean <italic>lattice</italic> or <italic>algebra</italic>
when taking the equivalence relation &#x2018;<inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau_1 == \tau_2$]]></texMath></inlineMaths>&#x2019; to be the relation induced by &#x2018;<inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau_1 =< \tau_2$]]></texMath></inlineMaths> <italic>and</italic> <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau_2 =< \tau_1$]]></texMath></inlineMaths>&#x2019; [Parreaux and Chau 2022a].</p>
<p>The rule S-T<sc>ag</sc>S<sc>ub</sc>} relates tags in an inheritance relation by stating that <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[${\#}{T_1}$]]></texMath></inlineMaths> is a subtype of <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[${\#}{T_2}$]]></texMath></inlineMaths> if <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T_1$]]></texMath></inlineMaths> transitively inherits from <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T_2$]]></texMath></inlineMaths>. The rule S-T<sc>ag</sc>B<sc>ot</sc>} states that the intersection of two unrelated tags is equivalent to <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\bot$]]></texMath></inlineMaths>.</p>
<p>The rules S-F<sc>un</sc>D<sc>epth</sc>} and S-R<sc>cd</sc>D<sc>epth</sc>} are the standard depth subtyping rules for functions and records respectively. All &#x25B7; in the set of hypotheses are eliminated in the premises. The rules S-F<sc>un</sc>M<sc>rg</sc>} and S-R<sc>cd</sc>M<sc>rg</sc>} merge intersections and unions of functions and records respectively by pushing the connectives inside the type constructor, swapping the connective for its dual for the argument type of functions due to its contravariance. The rule S-R<sc>cd</sc>T<sc>op</sc>} states that a union of two records with distinct fields, or of a record and a function is equivalent to <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\top$]]></texMath></inlineMaths>.</p>
</sec>
<sec id="sec">
<label>2.6</label>
<title>Extensible Variants in MLstruct<sup>+</sup></title>
<p>Consider variant types as in the example of Section 1 (<inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathsf{Some} \sqcap \{\mathsf{value}: \alpha\} \,\sqcup\, \beta \sqcap \neg\,\mathsf{Some} \sqcap \mathsf{Obj}$]]></texMath></inlineMaths>).</p>
<p>One can remove a tag <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T_i$]]></texMath></inlineMaths> from a variant type <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$(\textit{T}_1 \sqcap \cdots) \sqcup (\textit{T}_2 \sqcap \cdots) \sqcup \cdots$]]></texMath></inlineMaths> by taking the <italic>intersection</italic> of that type with the <italic>negation</italic> of the tag, i.e., <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$((\textit{T}_1 \sqcap \cdots) \sqcup (\textit{T}_2 \sqcap \cdots) \sqcup \cdots) \sqcap \neg\textit{T}_i$]]></texMath></inlineMaths>. For instance, <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$(\mathsf{Some} \sqcap \rcd{\mathsf{value}: \alpha}\,\sqcup\, \beta \sqcap \neg\,\mathsf{Some} \sqcap \mathsf{Obj}) \sqcap \neg\,\mathsf{Some}$]]></texMath></inlineMaths> is equivalent to just <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\beta \sqcap \neg\,\mathsf{Some} \sqcap \mathsf{Obj}$]]></texMath></inlineMaths>.
</p></sec>
<sec id="sec">
<label>2.7</label>
<title>Extensible Records in MLstruct<sup>+</sup></title>
<p>A naive way of typing the extension of a record of type <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau$]]></texMath></inlineMaths> to a new field <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$a$]]></texMath></inlineMaths> with a value of type <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\pi$]]></texMath></inlineMaths> is to yield the bound type <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau \sqcap \{a:\pi\}$]]></texMath></inlineMaths>. This does not work, however: if <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau$]]></texMath></inlineMaths> already contains a field <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$a$]]></texMath></inlineMaths> of type <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau'$]]></texMath></inlineMaths>, then this means that the resulting type is a subtype of <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\{a: \tau&#x2019; \sqcap \pi\}$]]></texMath></inlineMaths>, which is clearly not true in general. Thankfully, we can circumvent this while staying within Boolean-algebraic subtyping.</p>
<p>Similar to the removal of a tagged record from an extensible variant, one can remove a record field <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$a_i$]]></texMath></inlineMaths> from a record type <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\{a_1:\tau_1\}\sqcap\{a_2:\tau_2\}\sqcap\cdots$]]></texMath></inlineMaths> by taking the <italic>union</italic> of that type with the <italic>negation</italic> of the field <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\{a_1:\tau_1\}\sqcap\{a_2:\tau_2\}\sqcap\cdots\sqcup\neg\{a_i:\bot\}$]]></texMath></inlineMaths>. We can show that this record type admits all the fields <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$a_1$]]></texMath></inlineMaths> through <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$a_n$]]></texMath></inlineMaths> except for <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$a_i$]]></texMath></inlineMaths> and that an extension of the language with record removal and record extension based on these types is sound.</p>
<p>This only works thanks to the powerful algebraic properties of  Boolean-algebraic subtyping. Indeed, the S-RcdTop rule states that <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\top \leq \{a:\tau_1\} \sqcup \{b:\tau_2\}$]]></texMath></inlineMaths> when <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$a \neq b$]]></texMath></inlineMaths>. This means in particular that <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\neg\{a:\tau_1\} \leq \{b:\tau_2\}$]]></texMath></inlineMaths> (<inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$a \neq b$]]></texMath></inlineMaths>) and that <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\{a_1:\tau_1\}\sqcap\{a_2:\tau_2\}\sqcap\cdots\sqcup\neg\{a_i:\bot\} \leq \{a_j:\tau_j\}$]]></texMath></inlineMaths> for all <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$j \neq i$]]></texMath></inlineMaths> This means we can {widen} the value&#x2019;s type to the smaller record type.</p>
<p>In conclusion, MLstruct<sup>+</sup> does not need row polymorphism, as the corresponding extensible programming patterns can be encoded <italic>both</italic> for extensible variants and for extensible records, in ways that are dual to each other.</p>
</sec>
<sec id="sec3">
<label>3</label>
<title>Polymorphism, Consistency, and Soundness</title>
<p>MLstruct<sup>+</sup> expressions are typed under polymorphic type schemes made of type variables <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\alpha$]]></texMath></inlineMaths> and bounds <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{B}$]]></texMath></inlineMaths>, which Sulzmann et al. [1999] calls a &#x201C;type system in constrained form&#x201C; and is related to the classical <italic>constrained types</italic> approach [Odersky et al. 1999; Trifonov and Smith 1996] and is called <italic>multi-bounded polymorphism</italic> by [Parreaux et al. 2024]. Because type variables can be bounded on both sides, we must ensure that these bounds are <italic>consistent</italic>, otherwise one could use unsound assumptions to type check programs that go wrong by transitivity of subtyping</p></sec>
<sec id="sec3_1">
<label>3.1</label>
<title>Type Variables  &#x0026;  Polymorphism</title>
<p>In line with ML-style type inference, which is based on <italic>prenex polymorphism</italic>, we seek to assign <italic>type schemes</italic> to the term definitions and body of a program. We could write such type schemes <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\fa\overline{\alpha}\{\mathcal{B\}.\,\tau$]]></texMath></inlineMaths>, as is done by in the work of [Parreaux et al. 2024], where <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\overline{\alpha}$]]></texMath></inlineMaths> are the type variables being quantified and <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{B}$]]></texMath></inlineMaths> is their bounds. However, since in this work we focus on polymorphism only for top-level definitions (we do not support nested let polymorphism, although the extension is easy), we instead use the more compact notation <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\fa\mathcal{B.\,\tau$]]></texMath></inlineMaths>, whereby all variables mentioned in <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{B}$]]></texMath></inlineMaths> are implicitly quantified.</p>
<p>The type schemes of a definition is implicitly and eagerly instantiated whenever the definition is used, so that type checking/inference and constraint solving only ever deal with <italic>monomorphic</italic> types: the polymorphism is only at the top level and not part of the core subtyping system.</p>
</sec>
<sec id="sec">
<label>3.2</label>
<title>Consistency of Bounds Contexts</title>
<p>A crucial aspect of polymorphic type inference with bounds is that we must ensure that these bounds are <italic>consistent</italic>, in the sense that they are &#x201C;meaningful&#x201D; and do not lead to contradictions in the type system. For example, we must prevent typing definitions with such bounds as <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\fa(\tyCtor{Bool=<\alpha=<\tyCtor{Int).\,\tau$]]></texMath></inlineMaths>, which is a shorthand for <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\fa(\tyCtor{Bool=<\alpha)\ctxConcat(\alpha =< \tyCtor{Int).\,\tau$]]></texMath></inlineMaths>. Indeed, in the body of the corresponding definition, this would allow one to implicitly <italic>upcast</italic> any value of type <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tyCtor{Int$]]></texMath></inlineMaths> into a value of type <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tyCtor{Bool$]]></texMath></inlineMaths>, due to the assumptions on the bounds of <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\alpha$]]></texMath></inlineMaths> (leveraged by S-H<sc>yp</sc>) and the transitivity of subtyping implying that <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tyCtor{Bool=<\tyCtor{Int$]]></texMath></inlineMaths>.</p>
<p>We denote by <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\consistent\mathcal{B\,|\, \rho$]]></texMath></inlineMaths> that a bounds context <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{B}$]]></texMath></inlineMaths> is consistent <italic>as witnessed</italic> by a substitution <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\rho$]]></texMath></inlineMaths>. We also just write <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\consistent\mathcal{B}$]]></texMath></inlineMaths> when the witness does not need to be named. There are several possible ways of defining a consistency criterion that ensures the soundness of the type system.</p>
<sec id="sec">
<label>3.2.1</label>
<title>Classical Consistency</title>
<p>The most obvious approach is to define consistency as follows:</p>
<disp-formula id="eqn"><label></label><mml:math display='block'><mml:mfrac><mml:mrow><mml:mo>&#x22A8;</mml:mo><mml:mi>&#x03C1;</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mi mathvariant="script">B</mml:mi></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mrow><mml:mi mathvariant="script">B</mml:mi></mml:mrow><mml:msup><mml:mtext>&#x00A0;cons.&#x00A0;</mml:mtext><mml:mrow><mml:mo>&#x22C6;</mml:mo></mml:mrow></mml:msup><mml:mo>&#x2223;</mml:mo><mml:mi>&#x03C1;</mml:mi></mml:mrow></mml:mfrac></mml:math></disp-formula>
<p>That is, a bounds context <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{B}$]]></texMath></inlineMaths> is considered consistent if there exists a substitution <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\rho$]]></texMath></inlineMaths> that makes all the constraints hold in the empty context, written <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\ep |= \rho(\mathcal{B)$]]></texMath></inlineMaths> or just <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$|= \rho(\mathcal{B)$]]></texMath></inlineMaths>.</p>
<p>While this definition is quite simple and intuitive, it describes a rather <italic>strong</italic> consistency criterion. To see that, consider the bounds context <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$(\top&#x2192;\alpha=<\alpha)\cdot(\alpha=<\top&#x2192;\alpha)$]]></texMath></inlineMaths>, which is cyclic and essentially makes <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\alpha$]]></texMath></inlineMaths> describe a <italic>recursive type</italic>. Such type schemes are important to support since they are required for complete  &#x0026;  principal type inference, so we cannot simply reject them. But to show that this bounds context is classically consistent requires the existence of some form of first-class recursive or infinite types as primitives of the underlying type system. Here, the substitution <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\rho$]]></texMath></inlineMaths> would have to map <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\alpha$]]></texMath></inlineMaths> to a type that is a function type from <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\top$]]></texMath></inlineMaths> to itself. We usually write these types using a <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mu$]]></texMath></inlineMaths> binder, as in <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\recTy{X}\top&#x2192;X$]]></texMath></inlineMaths>.</p>
<p>While the requirement that <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mu$]]></texMath></inlineMaths> types (or equivalent) should be available as one of the core type constructors of the system is not a fundamental problem, it has two major disadvantages:
<list list-type="bullet">
<list-item><p>It can <italic>complicate</italic> the formal developments, requiring the handling of all possible uses of <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mu$]]></texMath></inlineMaths> types in the metatheory.</p></list-item><list-item><p>It is <italic>unsatisfying</italic> from a practical and theoretical point of view, in that the real type system of the programming language under study may already have its own notion of recursive types (e.g., user-defined type aliases and class types) and <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mu$]]></texMath></inlineMaths> types would play double duty with them, flaunting the principle of <italic>economy of concepts</italic>. We would really rather like for a generic theory of Boolean-algebraic subtyping like that of MLstruct<sup>+</sup> to not make strong assumptions on the constructors of the underlying language beyond the existence of the base Boolean-algebraic connectives.</p></list-item>
</list></p>
<p>While this strong consistency definition is sufficient to achieve soundness (making it impossible to, say, upcast integers to Booleans), it is in fact not <italic>necessary</italic>.</p>
</sec>
<sec id="sec">
<label>3.2.2</label>
<title>Towards Elementary Consistency</title>
<p>It is possible to design an alternative, more syntactic but also more permissive definition of consistency that does <italic>not</italic> assume the existence of recursive structures in the base type forms and instead relies purely on type variables and the &#x25B7; modality. We call this elementary consistency, or just <italic>consistency</italic> in the rest of this article.</p>
<p>Recall that the goal of consistency is to prevent problematic assumption from being used by S-H<sc>yp</sc> in a subtyping derivation. We achieve this by requiring each of the assumptions (after substitution) to be derivable under the <italic>guarded</italic> context, so that S-H<sc>yp</sc> cannot be used on the top level, and hence cannot introduce immediate inconsistencies:</p>
<disp-formula id="eqn"><label></label><mml:math display='block'><mml:mo>&#x25B9;</mml:mo><mml:mrow><mml:mi mathvariant="script">B</mml:mi></mml:mrow><mml:mo>&#x22A8;</mml:mo><mml:mi>&#x03C1;</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mi mathvariant="script">B</mml:mi></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:math></disp-formula>
<p>However, this is not sufficient on its own. Recall that our type system allows program bodies to be typed under any consistent context <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{B}$]]></texMath></inlineMaths> (see rule T-B<sc>ody</sc>).<xref ref-type="fn" id="fn9"><sup>9</sup></xref> Because of this, we must be able to reduce terms under contextual assumptions, and for type preservation to hold, we need to be able to invert subtyping judgments in consistent contexts. But the sole premise above does not rule out contexts that imply indirect subtyping relationships that might be unsound. For instance, consider the bounds context <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{B} = (\rcd{a:\mathsf{Int}=<\alpha)\ctxConcatSp{(\alpha=<\{\,a:\be\,\})}$]]></texMath></inlineMaths>. We can satisfy <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\rhd\mathcal{B} |= \rho(\mathcal{B)$]]></texMath></inlineMaths> by picking <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\rho = [\alpha|&#x2192;\rcd{a:\mathsf{Int},\,\be|&#x2192;\tyCtor{Int]$]]></texMath></inlineMaths>. But due to the lack of decomposition rules, even though we have <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\rcd{a: \mathsf{Int} =< \{\,a: \be\,\}$]]></texMath></inlineMaths> by transitivity, we do not have <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tyCtor{Int =< \be$]]></texMath></inlineMaths>. Thus reducing terms under that context may not preserve well-typedness
&#x2014; indeed, we can type <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{B},\epsilon |- \{\,a:42\,\}.a : \be$]]></texMath></inlineMaths> (remember that <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\epsilon$]]></texMath></inlineMaths> is the empty context), but this term reduces to <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$42$]]></texMath></inlineMaths>, and we do <italic>not</italic> have <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{B},\epsilon |- 42 : \be$]]></texMath></inlineMaths>.</p>
<p>This issue is due to leaving too much freedom for the substitution, allowing it to map type variables to types that are not implied by the type variable&#x2019;s bounds (i.e., in the example above, mapping <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\be|&#x2192;\tyCtor{Int$]]></texMath></inlineMaths>). To fix the issue, we take a step back and realize that we do not even need full substitutions to define a sufficient notion of consistency. This leads us to the following definition:</p>
<statement id="def-3_1">
<label>Definition 3.1</label>
<title>(Top-level substitution).</title>
<p>A top-level substitution <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tlsVar$]]></texMath></inlineMaths> substitutes all occurrences of type variables on the outermost layer of a type. The formal definition is given in appendix.</p>
</statement>
<p>Thanks to this definition, we can now finally define consistency as follows.</p>
<statement id="def-3_2">
<label>Definition 3.2</label>
<title>(Consistent context).</title>
<p><inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{B}$]]></texMath></inlineMaths> is <italic>consistent</italic> as witnessed by <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tlsVar$]]></texMath></inlineMaths>, written <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\scons[\tlsVar]{\mathcal{B}$]]></texMath></inlineMaths> if <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\rhd\mathcal{B} |= \tls\mathcal{B}$]]></texMath></inlineMaths> for some top-level substitution <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tlsVar$]]></texMath></inlineMaths>.</p>
</statement>
<p>Do note that we need to guard <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\rhd\mathcal{B}$]]></texMath></inlineMaths>, as otherwise <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\top=<\alpha=<\bot$]]></texMath></inlineMaths> would be considered consistent.</p>
</sec>
<sec id="sec">
<label>3.2.3</label>
<title>Properties of Consistent Contexts</title>
<p>Consistency has a few important properties. For example, it allows us to <italic>inline</italic> consistent bounds into existing subtyping derivations, which is crucial for showing the soundness of the type system. This is reflected in the following lemma statements, where <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathit{TTV}(\cdot)$]]></texMath></inlineMaths> enumerates the type variables on the top level of a type (i.e., not under a type constructor), formally defined in \ifdefined\ExcludeApps the appendix\elseAppendix~\ref{app:ftv}\fi.</p>
<statement id="lem-3_3">
<label>Lemma 3.3</label>
<title>(Inlining of bounds).</title>
<p>If <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\, \scons[\tlsVar]{\mathcal{B}$]]></texMath></inlineMaths> and <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{B} |- \tau =< \tau'$]]></texMath></inlineMaths>, then <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\rhd\mathcal{B} |- \tls\tau =< \tls{\tau'}$]]></texMath></inlineMaths>.</p>
</statement>

<p>P<sc>roof</sc>.   By preservation of subtyping under top-level substitution, we have <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tls\mathcal{B\ctxConcat{\rhd\mathcal{B} |- \tls\tau =< \tls{\tau'}$]]></texMath></inlineMaths>. By definition of consistency,
  <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\rhd\mathcal{B} |- \tls\mathcal{B}$]]></texMath></inlineMaths>, so we conclude by weakening.</p>

<statement id="cly-3_4">
<label>Corollary 3.4.</label>
<p>If <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\, \scons[\tlsVar]{\mathcal{B}$]]></texMath></inlineMaths> and <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{B} |- \tau =< \tau'$]]></texMath></inlineMaths> and <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathit{TTV}(\tau) \cup \mathit{TTV}(\tau') = \emptyset$]]></texMath></inlineMaths>, then <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\rhd\mathcal{B} |- \tau =< \tau'$]]></texMath></inlineMaths>.</p>
</statement>
</sec>
</sec>
<sec id="sec">
<label>3.3</label>
<title>Subtyping Derivation Shapes</title>
<p>We now give a few definitions characterizing the shapes of subtyping derivations, and state important properties concerning them (the proofs are in Appendix~\ref{app:subty-derivation-shapes}).</p>
<statement id="def-3_5">
<label>Definition 3.5</label>
<title>(Bottom-level rules).</title>
<p>A rule is used <italic>at the bottom level</italic> in a derivation if it is one of the following:</p>
<list id="list" list-type="number">
<list-item><p>the last rule used in the derivation;</p></list-item>
<list-item><p>either premise of a bottom-level application of rule S-T<sc>rans</sc>;</p></list-item>
<list-item><p>the first premise of a bottom-level application of rule T-S<sc>ubs</sc>.</p></list-item>
</list>
</statement>
<statement id="def-3_6">
<label>Definition 3.6</label>
<title>(Unassuming derivation).</title>
<p>An unassuming derivation is a subtyping derivation that does not make use of S-A<sc>ssum</sc> at the bottom level.</p>
</statement>
<statement id="lem-3_7">
<label>Lemma 3.7</label>
<title>(Unassuming derivation).</title>
<p><i>Any subtyping derivation can be rewritten to an equivalent unassuming derivation.</i></p>
</statement>
<p>P<sc>roof</sc>.   See Proof~\ref{prf:assum-procra}.</p>
</sec>
<sec id="sec3_4">
<label>3.4</label>
<title>Soundness Proofs</title>
<p>We present selected cases for the soundness proof. The full proof can be found in Appendix~\ref{sec:full-soundness}.</p>
<statement id="lem-3_7">
<label>Lemma 3.8</label>
<title>(Term progress).</title>
<p>If <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\, \epsilon,\epsilon |- t: \tau$]]></texMath></inlineMaths> and <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$t$]]></texMath></inlineMaths> is not a value then <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$t ~> t'$]]></texMath></inlineMaths> for some <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$t'$]]></texMath></inlineMaths>.</p>
</statement>
<p>P<sc>roof</sc>. By induction on typing derivations.</p>
\begin{description}
<list><list-item><p>Case T-E<sc>xt</sc>. <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$t = \rcdExtT{t_0}{a = t_a}$]]></texMath></inlineMaths></p>
<p>If <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$t_0$]]></texMath></inlineMaths> is not a value, by IH on the first premise we have <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$t_0 ~> t'$]]></texMath></inlineMaths> for some <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$t'$]]></texMath></inlineMaths> and thus <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\rcdExtT{t_0}{a = t_a} ~> \rcdExtT{t'}{a = t_a}$]]></texMath></inlineMaths> by E-C<sc>tx</sc>.</p>
<p>If <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$t_a$]]></texMath></inlineMaths> is not a value, by IH on the second premise we have <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$t_a ~> t_a'$]]></texMath></inlineMaths> for some <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$t_a'$]]></texMath></inlineMaths>, and thus <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\rcdExtT{t_0}{a = t_a} ~> \rcdExtT{t_0}{a = t_a'}$]]></texMath></inlineMaths> by E-C<sc>tx</sc>.</p>
<p>Otherwise, <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$t$]]></texMath></inlineMaths> is a value.</p></list-item>
<list-item><p>Case T-P<sc>roj</sc>. <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$t = t&#x2019;.a$]]></texMath></inlineMaths></p>
<p>If <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$t'$]]></texMath></inlineMaths> is not a value, by IH we have <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$t'~>t''$]]></texMath></inlineMaths>, and thus <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$t~>t&#x201D;.a$]]></texMath></inlineMaths> by E-C<sc>tx</sc>.</p>
<p>Otherwise, by canonical form for record types\ifdefined\ExcludeApps\else (Lemma~\ref{lem:canon-rcd})\fi, we have <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$t&#x2019; = \rcdExtT{v_0}{b = v_b}$]]></texMath></inlineMaths>, and therefore <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$t$]]></texMath></inlineMaths> progresses as either <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$t~>v_b$]]></texMath></inlineMaths> by E-P<sc>roj</sc>1 or <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$t~>v_0.a$]]></texMath></inlineMaths> by E-P<sc>roj</sc>2.</p></list-item>
<list-item><p>Case T-I<sc>f</sc>. <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$t = \iftag{x}{t_0}{T}{t_1}{t_2}$]]></texMath></inlineMaths></p>
<p>By IH, if <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$t_0$]]></texMath></inlineMaths> is not a value, then <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$t$]]></texMath></inlineMaths> progresses by E-C<sc>tx</sc>. Otherwise, since <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\textit{T} \sqcap \tau_1 \sqcup \neg\textit{T} \sqcap \mtext{Obj} \sqcap \tau_2 =< \mtext{Obj}$]]></texMath></inlineMaths>, we have <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\, \epsilon, \Gamma |- t_0: \mtext{Obj}$]]></texMath></inlineMaths> by T-S<sc>ubs</sc>. Then by canonical form for tag types\ifdefined\ExcludeApps\else (Lemma~\ref{lem:canon-tag})\fi, <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$t_0$]]></texMath></inlineMaths> is an object and <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$t$]]></texMath></inlineMaths> progresses by E-I<sc>f</sc>1 or E-I<sc>f</sc>2.</p></list-item>
<list-item><p><b>Remaining cases.</b> See Proof~\ref{prf:term-progress}.</p></list-item>
</list>

<statement id="lem-3_9">
<label>Lemma 3.9</label>
<title>(Term type preservation).</title>
<p>If <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\, \epsilon,\Gamma |- t: \tau$]]></texMath></inlineMaths> and <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\, t ~> t'$]]></texMath></inlineMaths>, then <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\, \epsilon,\Gamma |- t': \tau$]]></texMath></inlineMaths>.</p>
</statement>
<p>P<sc>roof</sc>. By induction on typing derivations. In the following, we sometimes abbreviate <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\, \epsilon,\Gamma |- t: \tau$]]></texMath></inlineMaths> to <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$t: \tau$]]></texMath></inlineMaths>.</p>
<list>
<list-item><p>Case T-E<sc>xt</sc>. <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$t = \rcdExtT{t_0}{a = t_1} \quad \tau = \tau_0 \fieldminusa \sqcap \{\,a: \tau_1\,\} \sqcap \textit{T} \quad t_0: \tau_0 \sqcap \textit{T} \quad t_1: \tau_1 t ~> t'$]]></texMath></inlineMaths> can only hold by E-C<sc>tx</sc>. The result follows by IH on the premise and T-E<sc>xt</sc>.</p></list-item>
<list-item><p>Case T-P<sc>roj</sc>. <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$t = t_0.a \quad t_0: \{\,a: \tau\,\}$]]></texMath></inlineMaths></p>
<p>If <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$t ~> t_0&#x2019;.a$]]></texMath></inlineMaths> by E-C<sc>tx</sc>, we conclude by IH on the premise and T-P<sc>roj</sc>.</p>
<p>If <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$t ~> v$]]></texMath></inlineMaths> reduces by E-P<sc>roj</sc>1, this means that <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$t_0 = \rcdExtT{v_0}{a = v}$]]></texMath></inlineMaths>. By inversion of object types \ifdefined\ExcludeApps\else (Lemma~\ref{lem:inv-obj}) \fi on the premise, we have <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$v: \tau$]]></texMath></inlineMaths>.</p>
<p>Otherwise, <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$t ~> v$]]></texMath></inlineMaths> reduces by E-P<sc>roj</sc>2, meaning that <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$t_0 = \rcdExtT{v}{b = v_b}$]]></texMath></inlineMaths> where <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$b \neq a$]]></texMath></inlineMaths>.  By inversion of object types \ifdefined\ExcludeApps\else (Lemma~\ref{lem:inv-obj}) \fi on the premise, we have <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$v: \{\,a: \tau\,\}$]]></texMath></inlineMaths>.</p></list-item>
<list-item><p>Case T-I<sc>f</sc>. <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$t = \iftag{x}{t_0}{T}{t_1}{t_2} \quad t_0: \textit{T} \sqcap \tau_1 \sqcup \neg\textit{T} \sqcap \mtext{Obj} \sqcap \tau_2$]]></texMath></inlineMaths></p>
<p>If the rule that applies is E-C<sc>tx</sc>, by IH.</p>
<p>Otherwise, if E-I<sc>f</sc>1 is the rule that applies, it means <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$t_0$]]></texMath></inlineMaths> is an instance of a subtag of <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T_2$]]></texMath></inlineMaths>, so by inversion of discriminated tag types \ifdefined\ExcludeApps\else (Lemma~\ref{lem:union-discrim}) \fi we know that <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\epsilon,\Gamma |- t_0: \tau_1$]]></texMath></inlineMaths>, and we can conclude by substitution\ifdefined\ExcludeApps\else (Lemma~\ref{lem:subst})\fi.</p>
<p>Otherwise, E-I<sc>f</sc>2 must be the rule that applies, so by inversion of discriminated tag types \ifdefined\ExcludeApps\else (Lemma~\ref{lem:union-discrim}) \fi we know that <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\epsilon,\Gamma |- t_0: \mtext{Obj} \sqcap \tau_2$]]></texMath></inlineMaths>, and we can conclude by T-S<sc>ubs</sc> with S-A<sc>nd</sc>O<sc>r</sc>11}- and substitution.</p></list-item>
<list-item><p><b>Remaining cases</b>. See the appendix.</p></list-item>
</list>
</sec></sec>
<sec id="sec4">
<label>4</label>
<title>Soundness of Boolean-Algebraic Subtyping</title>
<p>The reason we can incorporate rules such as S-F<sc>un</sc>M<sc>rg</sc>}, S-R<sc>cd</sc>M<sc>rg</sc>}, and S-R<sc>cd</sc>T<sc>op</sc>} is that they do not threaten any of the properties we need for the syntactic type soundness properties to hold. In this section, we demonstrate the soundness of Boolean-algebraic subtyping in MLstruct<sup>+</sup> by proving that it does not relate the type constructors of unrelated values and that it only relates related constructors in a sound way. The soundness of subtyping in MLstruct<sup>+</sup> is a key ingredient in showing that it can be used as a type-safe programming language whose well-typed programs &#x201C;<italic>do not go wrong</italic>&#x201D; and that other languages like Scala can safely be modeled after it.</p>
<sec id="sec4_1">
<label>4.1</label>
<title>High-Level Goal</title>
<p>Essentially, we want to prove the following property:</p>
<statement id="thm-4_1">
<label>Theorem 4.1</label>
<title>(Subtyping soundness).</title>
<p>If <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\scons{\mathcal{B}$]]></texMath></inlineMaths> and <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{B} |- \tau =< \pi$]]></texMath></inlineMaths>, where:</p>
<disp-formula id="eqn"><label></label><mml:math display='block'><mml:mi>&#x03C4;</mml:mi><mml:mo>&#x2208;</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mo>&#x22A5;</mml:mo><mml:mo>,</mml:mo><mml:mi mathvariant="normal">&#x22A4;</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>&#x03C4;</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">&#x2192;</mml:mo><mml:msub><mml:mi>&#x03C4;</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>T</mml:mi><mml:mrow><mml:mo>{</mml:mo><mml:msup><mml:mrow><mml:mover><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>:</mml:mo><mml:msub><mml:mi>&#x03C4;</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo accent="true">&#x2015;</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup><mml:mo>}</mml:mo></mml:mrow><mml:mo>}</mml:mo></mml:mrow><mml:mstyle scriptlevel="0"><mml:mspace width="1em"></mml:mspace></mml:mstyle><mml:mi>&#x03C0;</mml:mi><mml:mo>&#x2208;</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mo>&#x22A5;</mml:mo><mml:mo>,</mml:mo><mml:mi mathvariant="normal">&#x22A4;</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>&#x03C0;</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">&#x2192;</mml:mo><mml:msub><mml:mi>&#x03C0;</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi mathvariant="normal">#</mml:mi><mml:msup><mml:mi>T</mml:mi><mml:mrow><mml:mi>&#x2032;</mml:mi></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:msup><mml:mi>a</mml:mi><mml:mrow><mml:mi>&#x2032;</mml:mi></mml:mrow></mml:msup><mml:mo>:</mml:mo><mml:msub><mml:mi>&#x03C0;</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>}</mml:mo></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:math></disp-formula>
<p><i>then exactly one of the following is true:</i></p>
<list list-type="alpha-lower">
<list-item><p><inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau = \bot$]]></texMath></inlineMaths> or <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\pi = \top$]]></texMath></inlineMaths>;</p></list-item>
<list-item><p><inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau = \tau_1&#x2192;\tau_2$]]></texMath></inlineMaths> and <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\pi = \pi_1&#x2192;\pi_2$]]></texMath></inlineMaths> and <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{B} |- \pi_1 =< \tau_1$]]></texMath></inlineMaths> and <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{B} |- \tau_2 =< \pi_2$]]></texMath></inlineMaths>;</p></list-item>
<list-item><p><inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau = \obj{T}{\overline{a_i:\tau_i}^i}$]]></texMath></inlineMaths> and <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\pi = {\#}{T'}$]]></texMath></inlineMaths> and <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T \preceq T'$]]></texMath></inlineMaths>;</p></list-item>
<list-item><p><inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau = \obj{T}{\overline{a_i:\tau_i}^i}$]]></texMath></inlineMaths> and <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\pi = \{\,a_k:\pi_1\,\}$]]></texMath></inlineMaths> and <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{B} |- \tau_k =< \pi_1$]]></texMath></inlineMaths> for some <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$k$]]></texMath></inlineMaths>.</p></list-item>
</list></statement>
<p>This property can be read as follows: if the right-hand side of a subtyping relation is a function type and the left-hand side is the constructed type of a value (i.e., either a function type or an object type) or <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\bot$]]></texMath></inlineMaths> or <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\top$]]></texMath></inlineMaths>, then that constructed type must be either <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\bot$]]></texMath></inlineMaths> or a function type with compatible argument and return types, and similarly for the other right-hand side type constructors. This describes how the basic type constructors of the language should or should not relate by subtyping, and in particular prevents wrong relations, such as function types subtyping record types.</p>
<p>P<sc>roof</sc>. As we will see, this will be proved by a weaker form of the property where the context is guarded (Lemma~\ref{lem:semantic-consist-subt})  together with Corollary 3.4 to guard the context.</p>\subsection{Key Proof Idea}
</sec>
<sec id="sec4_2">
<label>4.2</label>
<title>Key Proof Idea</title>
<p>The key idea of our proof approach is to leverage the fact that our subtyping relation is relatively well-behaved, despite its non-uniform treatment of unions and intersections (i.e., the rules (1)&#x2014;(4) introduced in Section 1 that correspond to S-T<sc>ag</sc>B<sc>ot</sc>}, S-F<sc>un</sc>M<sc>rg</sc>}, and S-R<sc>cd</sc>T<sc>op</sc>}).</p>
<p>More specifically, we can often <italic>map</italic> Boolean-algebraic subtyping derivations into other derivations defined in some alternative Boolean algebra in a structure-preserving way, which is called a <italic>Boolean homomorphism</italic>. These alternative Boolean algebras can be the standard Boolean-algebraic subtyping types but with an unguarded context (when the original derivation was using a guarded one) or they can be completely different altogether. All we have to show is that our Boolean homomorphisms are <italic>monotonic</italic> with respect to our subtyping rules, which ensures that the resulting derivation is valid.</p>
</sec>
<sec id="sec4_2">
<label>4.2.1</label>
<title>Shape Homomorphisms</title>
<p>Consider the problem of showing that function types cannot possibly subtype record types of some field <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$a$]]></texMath></inlineMaths> in our system. To do so, we want to reject the existence of all subtyping derivations of the form <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau_1&#x2192;\tau_2=<\{\,a:\pi\,\}$]]></texMath></inlineMaths> by showing a contradiction.</p>
<p>One way to achieve this is to construct a Boolean homomorphism <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{S}$]]></texMath></inlineMaths> from the Boolean algebra of MLstruct<sup>+</sup> types to plain Boolean truth values <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$0$]]></texMath></inlineMaths> and <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$1$]]></texMath></inlineMaths>, which are ordered by <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$0 < 1$]]></texMath></inlineMaths>, mapping functions to <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$1$]]></texMath></inlineMaths> and records of field <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$a$]]></texMath></inlineMaths> to <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$0$]]></texMath></inlineMaths> respectively, i.e.,\
<disp-formula id="eqn"><label></label><mml:math display='block'><mml:mtable columnalign="right left right left" columnspacing="1em" rowspacing="4pt" name="array"><mml:mtr><mml:mtd><mml:mrow><mml:mi mathvariant="script">S</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">[</mml:mo></mml:mrow><mml:mo>&#x22A5;</mml:mo><mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mrow><mml:mi mathvariant="script">S</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">[</mml:mo></mml:mrow><mml:mi>&#x03C4;</mml:mi><mml:mo stretchy="false">&#x2192;</mml:mo><mml:mi>&#x03C0;</mml:mi><mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mi mathvariant="script">S</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">[</mml:mo></mml:mrow><mml:mi mathvariant="normal">&#x22A4;</mml:mi><mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mtd><mml:mtd><mml:mrow><mml:mi mathvariant="script">S</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">[</mml:mo></mml:mrow><mml:mo fence="false" stretchy="false">{</mml:mo><mml:mi>b</mml:mi><mml:mo>:</mml:mo><mml:mi>&#x03C4;</mml:mi><mml:mo fence="false" stretchy="false">}</mml:mo><mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mo>=</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mtable displaystyle="true" columnalign="right left right" columnspacing="0em 2em" rowspacing="3pt" name="aligned"><mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd></mml:mtd><mml:mtd><mml:mtext>&#x00A0;if&#x00A0;</mml:mtext><mml:mi>b</mml:mi><mml:mo>=</mml:mo><mml:mi>a</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mn>1</mml:mn></mml:mtd><mml:mtd></mml:mtd><mml:mtd><mml:mtext>&#x00A0;otherwise&#x00A0;</mml:mtext></mml:mtd></mml:mtr></mml:mtable><mml:mo fence="true" stretchy="true" symmetric="true"></mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mi mathvariant="script">S</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">[</mml:mo></mml:mrow><mml:mi mathvariant="normal">&#x00AC;</mml:mi><mml:mi>&#x03C4;</mml:mi><mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mo>=</mml:mo><mml:mi mathvariant="normal">&#x00AC;</mml:mi><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">[</mml:mo></mml:mrow><mml:mi>&#x03C4;</mml:mi><mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mi mathvariant="script">S</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">[</mml:mo></mml:mrow><mml:mi mathvariant="normal">#</mml:mi><mml:mi>T</mml:mi><mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula></p>
<p>We can then show that <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{S}$]]></texMath></inlineMaths> is monotonic: we inspect each subtyping rule and make sure that it is preserved after applying <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{S}$]]></texMath></inlineMaths>. Thanks to monotonicity, we can then reason that if there was indeed a derivation for <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau_1&#x2192;\tau_2=<\{\,a:\pi\,\}$]]></texMath></inlineMaths>, this would imply the existence of a derivation for <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{S}[|\tau_1&#x2192;\tau_2|] =< \mathcal{S}[|\{\,a:\pi\,\}|]$]]></texMath></inlineMaths>, ie, <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$1=<0$]]></texMath></inlineMaths>, a contradiction.</p>
<p>We call <italic>shape homomorphisms</italic> those that allow us to exclude impossible cases by contradiction in this way. Down the line, these are the ones that allow us to prove progress.</p>
</sec>
<sec id="sec">
<label>4.2.2</label>
<title>Component Homomorphisms</title>
<p>The other category of Boolean homomorphisms we use <italic>project out</italic> a sub-component of a type constructor of interest in order to reason about it separately.</p>
<p>For example, in order to prove that <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\{\,a_1: \tau_1\,\}\sqcap\{\,a_2:\tau_2\,\}=<\{\,a_1: \pi\,\}$]]></texMath></inlineMaths> <italic>implies</italic>

 <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau_1 =< \pi$]]></texMath></inlineMaths> when <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$a_1 \neq a_2$]]></texMath></inlineMaths>, we can define a specific homomorphism <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{K}$]]></texMath></inlineMaths> that maps any <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\{\,a_1: \pi'\,\}$]]></texMath></inlineMaths> to <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\pi'$]]></texMath></inlineMaths>, i.e., <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{K}[|\{\,a_1: \pi'\,\}|] = \pi'$]]></texMath></inlineMaths>, and maps all other record types to <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\top$]]></texMath></inlineMaths>, i.e., <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{K}[|\{\,a': \pi'\,\}|] = \top$]]></texMath></inlineMaths> when <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$a&#x2019; \neq a_1$]]></texMath></inlineMaths>. As before, we show that this homomorphism is monotonic by inspecting each subtyping rule in isolation. Thereafter, we can reason that if there is indeed a derivation of <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\{\,a_1: \tau_1\,\}\sqcap\{\,a_2:\tau_2\,\}=<\{\,a_1: \pi\,\}$]]></texMath></inlineMaths>, then there must also be a derivation of <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{K}[|\{\,a_1: \tau_1\,\}\sqcap\{\,a_2:\tau_2\,\}|]=<\mathcal{K}[|\{\,a_1: \pi\,\}|]$]]></texMath></inlineMaths>, ie, <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau_1 \sqcap \top =< \pi$]]></texMath></inlineMaths>, immediately implying the existence of a derivation for <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau_1 =< \pi$]]></texMath></inlineMaths>, which is the result we wanted.</p>
<p>We call <italic>component homomorphisms</italic> those that allow us to extract sub-components of types in this way. Down the line, these are the ones that allow us to prove type preservation.</p>
</sec>
<sec id="sec">
<label>4.2.3</label>
<title>Other Homomorphisms</title>
<p>This generic reasoning principle extends far beyond the proof of subtyping soundness. For example, we also use Boolean homomorphisms to prove the co-NP-hardness of subtyping in MLstruct<sup>+</sup>, as shown in Section 5.3.</p>
</sec>
</sec>
<sec id="sec4_3">
<label>4.3</label>
<title>Semantic Proof of Subtyping Soundness</title>
<p>The proof proceeds by constructing homomorphisms from the Boolean algebra of types to some other Boolean algebras with variables mapped to <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\top$]]></texMath></inlineMaths>, i.e., mappings <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$[|\cdot|]$]]></texMath></inlineMaths> where:</p>
<disp-formula id="eqn"><label></label><mml:math display='block'><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">[</mml:mo></mml:mrow><mml:mi>&#x03C4;</mml:mi><mml:msup><mml:mo>&#x2294;</mml:mo><mml:mrow><mml:mo>&#x00B1;</mml:mo></mml:mrow></mml:msup><mml:mi>&#x03C0;</mml:mi><mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">[</mml:mo></mml:mrow><mml:mi>&#x03C4;</mml:mi><mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:msup><mml:mo>&#x2294;</mml:mo><mml:mrow><mml:mo>&#x00B1;</mml:mo></mml:mrow></mml:msup><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">[</mml:mo></mml:mrow><mml:mi>&#x03C0;</mml:mi><mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mstyle scriptlevel="0"><mml:mspace width="1em"></mml:mspace></mml:mstyle><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">[</mml:mo></mml:mrow><mml:msup><mml:mi mathvariant="normal">&#x22A4;</mml:mi><mml:mrow><mml:mo>&#x00B1;</mml:mo></mml:mrow></mml:msup><mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:msup><mml:mi mathvariant="normal">&#x22A4;</mml:mi><mml:mrow><mml:mo>&#x00B1;</mml:mo></mml:mrow></mml:msup><mml:mstyle scriptlevel="0"><mml:mspace width="1em"></mml:mspace></mml:mstyle><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">[</mml:mo></mml:mrow><mml:mi mathvariant="normal">&#x00AC;</mml:mi><mml:mi>&#x03C4;</mml:mi><mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi mathvariant="normal">&#x00AC;</mml:mi><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">[</mml:mo></mml:mrow><mml:mi>&#x03C4;</mml:mi><mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mstyle scriptlevel="0"><mml:mspace width="1em"></mml:mspace></mml:mstyle><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">[</mml:mo></mml:mrow><mml:mi>&#x03B1;</mml:mi><mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi mathvariant="normal">&#x22A4;</mml:mi></mml:math></disp-formula>
<p>We then prove that the mappings we construct are monotonic by checking that the subtyping relation is compatible with each of them. We then deduce the desired properties from the properties of the target Boolean algebras. In particular, we show that for each form of <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\pi$]]></texMath></inlineMaths>, only a compatible form of <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau$]]></texMath></inlineMaths> is possible.</p>
<p>Since S-H<sc>yp</sc> can make use of arbitrary assumptions in the context, constructing homomorphisms compatible with S-H<sc>yp</sc> requires the target Boolean algebra to always be parameterized by a corresponding context, which significantly complicates the reasoning. This can be overcome by first inlining the bounds in the subtyping judgment, which in turn allows the entire context to be guarded. Thus, in the auxiliary Lemma~\ref{lem:semantic-consist-subt}, we can ignore subtyping rules with unguarded assumptions in the context, namely S-H<sc>yp</sc>.</p>
<p>Another consequence of considering only subtyping rules with guarded contexts is that type variables cannot be used in any meaningful way: they can only be introduced and eliminated by the pure Boolean-algebraic rules. This allows us to always map type variables to <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\top$]]></texMath></inlineMaths> regardless of its bounds while ensuring monotonicity. The choice of <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\top$]]></texMath></inlineMaths> here is in fact arbitrary: any element of the target Boolean algebra would suffice.</p>
<p>Notice that as the component homomorphisms map to a Boolean algebra of types, the order in the target Boolean algebra is also parameterized by a subtyping context, which in our case is the input context unguarded. For the shape homomorphisms, the target Boolean homomorhism are simple power sets, whose orders do not depend on a subtyping context, in which case the input subtyping context is simply discarded.</p>
<sec id="sec4_4">
<label>4.4</label>
<title>Boolean Homomorphisms</title>
<p>The five families of characteristic Boolean homomorphisms of Boolean-algebraic subtyping are summarized in Table~\ref{tab:homomorphisms}, where <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\subclasses\DCtxScript{T}$]]></texMath></inlineMaths> denotes the set <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\br{\,{S \mid S \preceq T}\,}$]]></texMath></inlineMaths> of all subtags of <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T$]]></texMath></inlineMaths>.</p>
<p>We do not directly include the two example homomorphisms from Sections 4.2.1 and 4.2.2 instead prefer to consolidate several shape homomorphisms and several component homomorphisms into single ones, reducing the total number of required definitions.</p>
<statement id="def-4_2">
<label>Definition 4.2</label>
<p>The mapping <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{H{[|\cdot|]}$]]></texMath></inlineMaths> is defined below. It is a Boolean homomorphism from the Boolean algebra of types to <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\powerset{\mathbf{U}}$]]></texMath></inlineMaths> ordered by inclusion, where <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathbf{U} = \mathcal{T \cup \setLit{{&#x2192;}, \mathsf{R}$]]></texMath></inlineMaths> is the set of tags together with the symbols &#x2192; and <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathsf{R$]]></texMath></inlineMaths>.</p>
<disp-formula id="eqn"><label></label><mml:math display='block'><mml:mrow><mml:mi mathvariant="script">H</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">[</mml:mo></mml:mrow><mml:msub><mml:mi>&#x03C4;</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">&#x2192;</mml:mo><mml:msub><mml:mi>&#x03C4;</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mo fence="false" stretchy="false">{</mml:mo><mml:mo stretchy="false">&#x2192;</mml:mo><mml:mo fence="false" stretchy="false">}</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="1em"></mml:mspace></mml:mstyle><mml:mrow><mml:mi mathvariant="script">H</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">[</mml:mo></mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mi>a</mml:mi><mml:mo>:</mml:mo><mml:msub><mml:mi>&#x03C4;</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>}</mml:mo></mml:mrow><mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mi mathvariant="bold">U</mml:mi></mml:mrow><mml:mstyle scriptlevel="0"><mml:mspace width="1em"></mml:mspace></mml:mstyle><mml:mrow><mml:mi mathvariant="script">H</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">[</mml:mo></mml:mrow><mml:mi mathvariant="normal">#</mml:mi><mml:mi>T</mml:mi><mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mo>=&#x2264;</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></disp-formula>
</statement>
<statement id="def-4_3">
<label>Lemma 4.3</label>
<p>\begin{lemma} <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{H{[|\cdot|]}$]]></texMath></inlineMaths> is monotonic.</p>
</statement>
<table id="tab-1">
<label>Table 1.</label>
<caption><p>Summary of the characteristic Boolean homomorphisms of BAS, where <inline-formula><mml:math display='inline'><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow></mml:math></inline-formula> is the set of all tag names, <inline-formula><mml:math display='inline'><mml:mrow><mml:mi mathvariant="script">F</mml:mi></mml:mrow></mml:math></inline-formula> is the set of all record field labels, <inline-formula><mml:math display='inline'><mml:mo stretchy="false">&#x2192;</mml:mo></mml:math></inline-formula> and R are constants, <inline-formula><mml:math display='inline'><mml:mrow><mml:mi mathvariant="normal">U</mml:mi></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mi mathvariant="script">T</mml:mi></mml:mrow><mml:mo>&#x222A;</mml:mo><mml:mo fence="false" stretchy="false">{</mml:mo><mml:mo stretchy="false">&#x2192;</mml:mo><mml:mo>,</mml:mo><mml:mrow><mml:mi mathvariant="normal">R</mml:mi></mml:mrow><mml:mo fence="false" stretchy="false">}</mml:mo></mml:math></inline-formula>, and <inline-formula><mml:math display='inline'><mml:mo>&#x2264;</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo fence="false" stretchy="false">{</mml:mo><mml:mi>S</mml:mi><mml:mo>&#x2223;</mml:mo><mml:mi>S</mml:mi><mml:mo>&#x2264;</mml:mo><mml:mi>T</mml:mi><mml:mo fence="false" stretchy="false">}</mml:mo></mml:math></inline-formula>.</p></caption>
<tbody>
<tr>
<td align="left">Def.</td>
<td align="left">Not.</td>
<td align="left"><inline-formula><mml:math display='inline'><mml:mo>&#x22C5;</mml:mo><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">[</mml:mo></mml:mrow><mml:mi>&#x03C4;</mml:mi><mml:mo stretchy="false">&#x2192;</mml:mo><mml:mi>&#x03C0;</mml:mi><mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula></td>
<td align="left"><inline-formula><mml:math display='inline'><mml:mo>&#x22C5;</mml:mo><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">[</mml:mo></mml:mrow><mml:mo fence="false" stretchy="false">{</mml:mo><mml:mi>a</mml:mi><mml:mo>:</mml:mo><mml:mi>&#x03C4;</mml:mi><mml:mo fence="false" stretchy="false">}</mml:mo><mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula></td>
<td align="left">-<inline-formula><mml:math display='inline'><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">[</mml:mo></mml:mrow><mml:mi mathvariant="normal">#</mml:mi><mml:mi>T</mml:mi><mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula></td>
<td align="left">-<inline-formula><mml:math display='inline'><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">[</mml:mo></mml:mrow><mml:mrow><mml:mi mathvariant="normal">T</mml:mi></mml:mrow></mml:math></inline-formula> &#x25A0;</td>
<td align="left"><inline-formula><mml:math display='inline'><mml:mo>&#x22C5;</mml:mo><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">[</mml:mo></mml:mrow><mml:mo>&#x22A5;</mml:mo><mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula></td>
<td align="left"><inline-formula><mml:math display='inline'><mml:mo>&#x22C5;</mml:mo><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">[</mml:mo></mml:mrow><mml:mo>&#x2264;</mml:mo><mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula></td>
</tr>
<tr>
<td align="left">4.2</td>
<td align="left"><inline-formula><mml:math display='inline'><mml:mrow><mml:mi mathvariant="script">H</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">[</mml:mo></mml:mrow><mml:mo>&#x22C5;</mml:mo><mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula></td>
<td align="left"><inline-formula><mml:math display='inline'><mml:mo fence="false" stretchy="false">{</mml:mo><mml:mo stretchy="false">&#x2192;</mml:mo><mml:mo fence="false" stretchy="false">}</mml:mo></mml:math></inline-formula></td>
<td align="left">U</td>
<td align="left"><inline-formula><mml:math display='inline'><mml:mo>&#x2264;</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:math></inline-formula></td>
<td align="left">U</td>
<td align="left"><inline-formula><mml:math display='inline'><mml:mi>&#x2205;</mml:mi></mml:math></inline-formula></td>
<td align="left"><inline-formula><mml:math display='inline'><mml:mo>&#x2286;</mml:mo></mml:math></inline-formula></td>
</tr>
<tr>
<td align="left">4.4</td>
<td align="left"><inline-formula><mml:math display='inline'><mml:mrow><mml:mi mathvariant="script">I</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">[</mml:mo></mml:mrow><mml:mo>&#x22C5;</mml:mo><mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula></td>
<td align="left"><inline-formula><mml:math display='inline'><mml:mrow><mml:mi mathvariant="normal">U</mml:mi></mml:mrow><mml:mo>&#x00D7;</mml:mo><mml:mrow><mml:mi mathvariant="script">F</mml:mi></mml:mrow></mml:math></inline-formula></td>
<td align="left"><inline-formula><mml:math display='inline'><mml:mrow><mml:mi mathvariant="bold">U</mml:mi></mml:mrow><mml:mo>&#x00D7;</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mi mathvariant="script">F</mml:mi></mml:mrow><mml:mi mathvariant="normal">&#x2216;</mml:mi><mml:mo fence="false" stretchy="false">{</mml:mo><mml:mi>a</mml:mi><mml:mo fence="false" stretchy="false">}</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:math></inline-formula></td>
<td align="left"><inline-formula><mml:math display='inline'><mml:mo>&#x2264;</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>&#x00D7;</mml:mo><mml:mrow><mml:mi mathvariant="script">F</mml:mi></mml:mrow></mml:math></inline-formula></td>
<td align="left"><inline-formula><mml:math display='inline'><mml:mrow><mml:mi mathvariant="normal">U</mml:mi></mml:mrow><mml:mo>&#x00D7;</mml:mo><mml:mrow><mml:mi mathvariant="script">F</mml:mi></mml:mrow></mml:math></inline-formula></td>
<td align="left"><inline-formula><mml:math display='inline'><mml:mi>&#x2205;</mml:mi></mml:math></inline-formula></td>
<td align="left"><inline-formula><mml:math display='inline'><mml:mo>&#x2286;</mml:mo></mml:math></inline-formula></td>
</tr>
<tr>
<td align="left">4.6</td>
<td align="left"><inline-formula><mml:math display='inline'><mml:mrow><mml:mi mathvariant="script">J</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">[</mml:mo></mml:mrow><mml:mo>&#x22C5;</mml:mo><mml:msubsup><mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mrow><mml:mi>S</mml:mi></mml:mrow></mml:msubsup></mml:math></inline-formula></td>
<td align="left">T</td>
<td align="left"><div class="inline-tabular sub-table"><table class="tabular">
<tbody>
<tr>
<td align="left"><inline-formula><mml:math display='inline'><mml:mi>&#x03C4;</mml:mi><mml:mstyle scriptlevel="0"><mml:mspace width="1em"></mml:mspace></mml:mstyle></mml:math></inline-formula> if <inline-formula><mml:math display='inline'><mml:mi>b</mml:mi><mml:mo>=</mml:mo><mml:mi>a</mml:mi></mml:math></inline-formula></td>
</tr>
<tr>
<td align="left">T otherwise</td>
</tr>
</tbody>
</table>
<p>P<sc>roof</sc>.   We show that the subtyping relation is compatible with <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{H{[|\cdot|]}$]]></texMath></inlineMaths>. The only non-trivial cases are S-T<sc>ag</sc>S<sc>ub</sc>} and S-T<sc>ag</sc>B<sc>ot</sc>}.</p>
<list>
<list-item><p>Case S-T<sc>ag</sc>S<sc>ub</sc>. The rule has premise <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T_1 \preceq T_2$]]></texMath></inlineMaths> and conclusion <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[${\#}{T_1} =< {\#}{T_2}$]]></texMath></inlineMaths>. By transitivity of inheritance, all subtags of <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T_1$]]></texMath></inlineMaths> are also subtags of <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T_2$]]></texMath></inlineMaths>, i.e., <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\subclasses\DCtxScript{{T_1}} \subseteq \subclasses\DCtxScript{{T_2}}$]]></texMath></inlineMaths>.</p></list-item>
<list-item><p>Case S-T<sc>ag</sc>B<sc>ot</sc>. The rule has premises <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T_2 \not\preceq T_1$]]></texMath></inlineMaths>  and <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T_1 \not\preceq T_2$]]></texMath></inlineMaths>, i.e., <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T_1$]]></texMath></inlineMaths> and <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T_2$]]></texMath></inlineMaths> are unrelated, and conclusion <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[${\#}{T_1} \sqcap {\#}{T_2} =< \bot$]]></texMath></inlineMaths>. Due to single inheritance, subtags of <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T_1$]]></texMath></inlineMaths> cannot also be subtags of <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T_2$]]></texMath></inlineMaths> without the two being related. Therefore, <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\subclasses\DCtxScript{{T_1}} \cap \subclasses\DCtxScript{{T_2}} = \emptyset$]]></texMath></inlineMaths> and the conclusion reduces to <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\emptyset \subseteq \emptyset$]]></texMath></inlineMaths>.</p></list-item>
</list>
<statement id="rmk-4_1">
<label>Remark 4.1</label>
<p>This homomorphism is critical in ensuring that subtyping relates type constructors of compatible <italic>shapes</italic>. The presence of a rule like <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\{ a : \bot \} \leqslant \bot$]]></texMath></inlineMaths>, which is commonly seen in set-theoretic subtyping systems, would prevent us from using such a homomorphism, at least in its simple form: such a rule would require that <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{H[|\{\,a : \tau\,\}|]  \subseteq  \mathcal{H[|\bot|] = \varnothing$]]></texMath></inlineMaths> for any <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau$]]></texMath></inlineMaths> equivalent to <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\bot$]]></texMath></inlineMaths>;  this would in turn require us to map records to <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\varnothing$]]></texMath></inlineMaths>, but that would collapse the types of object values, preventing us from concluding the soundness proof by ruling out impossible cases  (as we will see in the proof of Lemma~\ref{lem:semantic-consist-subt} on page \pageref{proof:semantic-consist-subt}). It is possible that a more refined mapping could be defined and used, but doing so would significantly complicate the proof.</p>
</statement>
<statement id="def-4_4">
<label>Definition 4.4</label>
<p>The Boolean homomorphism <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{I{[|\cdot|]}$]]></texMath></inlineMaths> from the Boolean algebra of types to <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\powerset{\mathbf{U} \times \mathcal{F}$]]></texMath></inlineMaths> ordered by inclusion, where <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathbf{U} = \mathcal{T \cup \setLit{{&#x2192;}, \mathsf{R}$]]></texMath></inlineMaths> is the set of tags together with the symbols &#x2192; and <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathsf{R$]]></texMath></inlineMaths>; and <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{F = \setLitTight{\overline{a}}$]]></texMath></inlineMaths> is the set of record field labels, is defined as:</p>
<p><disp-formula id="eqn"><label></label><mml:math display='block'><mml:mrow><mml:mi mathvariant="script">I</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">[</mml:mo></mml:mrow><mml:msub><mml:mi>&#x03C4;</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">&#x2192;</mml:mo><mml:msub><mml:mi>&#x03C4;</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mi mathvariant="normal">U</mml:mi></mml:mrow><mml:mo>&#x00D7;</mml:mo><mml:mrow><mml:mi mathvariant="script">F</mml:mi></mml:mrow><mml:mstyle scriptlevel="0"><mml:mspace width="1em"></mml:mspace></mml:mstyle><mml:mrow><mml:mi mathvariant="script">I</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">[</mml:mo></mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mi>a</mml:mi><mml:mo>:</mml:mo><mml:msub><mml:mi>&#x03C4;</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>}</mml:mo></mml:mrow><mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mi mathvariant="normal">U</mml:mi></mml:mrow><mml:mo>&#x00D7;</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mi mathvariant="script">F</mml:mi></mml:mrow><mml:mi mathvariant="normal">&#x2216;</mml:mi><mml:mo fence="false" stretchy="false">{</mml:mo><mml:mi>a</mml:mi><mml:mo fence="false" stretchy="false">}</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="1em"></mml:mspace></mml:mstyle><mml:mrow><mml:mi mathvariant="script">I</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">[</mml:mo></mml:mrow><mml:mi mathvariant="normal">#</mml:mi><mml:mi>T</mml:mi><mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mo>=&#x2264;</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>&#x00D7;</mml:mo><mml:mrow><mml:mi mathvariant="script">F</mml:mi></mml:mrow></mml:math></disp-formula></p>
</statement>
<statement id="lem-4_5">
<label>Lemma 4.5</label>
<p><inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{I{[|\cdot|]}$]]></texMath></inlineMaths> is monotonic.lemma</p></statement>
<p>P<sc>roof</sc>. We show that the subtyping relation is compatible with <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{I{[|\cdot|]}$]]></texMath></inlineMaths>. The only non-trivial cases are S-T<sc>ag</sc>S<sc>ub</sc>}, S-T<sc>ag</sc>B<sc>ot</sc>}, and S-R<sc>cd</sc>T<sc>op</sc>}.</p>

<list>
<list-item><p>Case S-T<sc>ag</sc>S<sc>ub</sc>. The rule has premise <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T_1 \preceq T_2$]]></texMath></inlineMaths>    and conclusion <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[${\#}{T_1} =< {\#}{T_2}$]]></texMath></inlineMaths>. By transitivity of inheritance, we have <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\subclasses\DCtxScript{{T_1}} \subseteq \subclasses\DCtxScript{{T_2}}$]]></texMath></inlineMaths>, which implies the mapped conclusion <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\subclasses\DCtxScript{{T_1}} \times \mathcal{F \subseteq \subclasses\DCtxScript{{T_2}} \times \mathcal{F$]]></texMath></inlineMaths>.</p></list-item>
<list-item><p>Case S-T<sc>ag</sc>B<sc>ot</sc>. The rule has premises <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T_2 \not\preceq T_1$]]></texMath></inlineMaths> and <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T_1 \not\preceq T_2$]]></texMath></inlineMaths>, i.e., <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T_1$]]></texMath></inlineMaths> and <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T_2$]]></texMath></inlineMaths> are unrelated, and conclusion <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[${\#}{T_1} \sqcap {\#}{T_2} =< \bot$]]></texMath></inlineMaths>. A subtag of <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T_1$]]></texMath></inlineMaths> cannot also be a subtag of <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T_2$]]></texMath></inlineMaths> at the same time due to single inheritance. Therefore, we have <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\subclasses\DCtxScript{{T_1}} \cap \subclasses\DCtxScript{{T_2}} = \emptyset$]]></texMath></inlineMaths>. The LHS then reduces to:</p>
<disp-formula id="eqn"><label></label><mml:math display='block'><mml:mtable displaystyle="true" columnalign="right left" columnspacing="0em" rowspacing="3pt" name="aligned"><mml:mtr><mml:mtd><mml:mrow><mml:mi mathvariant="script">I</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">[</mml:mo></mml:mrow><mml:mi mathvariant="normal">#</mml:mi><mml:msub><mml:mi>T</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>&#x2293;</mml:mo><mml:mi mathvariant="normal">#</mml:mi><mml:msub><mml:mi>T</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mi></mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mo>&#x2264;</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi>T</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mo>&#x00D7;</mml:mo><mml:mrow><mml:mi mathvariant="script">F</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>&#x2229;</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mo>&#x2264;</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi>T</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mo>&#x00D7;</mml:mo><mml:mrow><mml:mi mathvariant="script">F</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd></mml:mtd><mml:mtd><mml:mi></mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mo>&#x2264;</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi>T</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mo>&#x2229;</mml:mo><mml:mo>&#x2264;</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:msub><mml:mi>T</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>)</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>&#x00D7;</mml:mo><mml:mrow><mml:mi mathvariant="script">F</mml:mi></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd></mml:mtd><mml:mtd><mml:mi></mml:mi><mml:mo>=</mml:mo><mml:mi>&#x2205;</mml:mi><mml:mo>&#x00D7;</mml:mo><mml:mrow><mml:mi mathvariant="script">F</mml:mi></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd></mml:mtd><mml:mtd><mml:mi></mml:mi><mml:mo>=</mml:mo><mml:mi>&#x2205;</mml:mi></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula>
<p>Therefore, the conclusion reduces to <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\emptyset \subseteq \emptyset$]]></texMath></inlineMaths>.</p></list-item>
<list-item><p>Case S-R<sc>cd</sc>T<sc>op</sc>.
<disp-formula id="eqn"><label></label><mml:math display='block'><mml:mtable displaystyle="true" columnalign="right left" columnspacing="0em" rowspacing="3pt" name="aligned"><mml:mtr><mml:mtd><mml:mrow><mml:mi mathvariant="script">I</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">[</mml:mo></mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mi>a</mml:mi><mml:mo>:</mml:mo><mml:msub><mml:mi>&#x03C4;</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>}</mml:mo></mml:mrow><mml:mo>&#x2294;</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mi>b</mml:mi><mml:mo>:</mml:mo><mml:msub><mml:mi>&#x03C4;</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>}</mml:mo></mml:mrow><mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mi></mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mi mathvariant="bold">U</mml:mi></mml:mrow><mml:mo>&#x00D7;</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mi mathvariant="script">F</mml:mi></mml:mrow><mml:mi mathvariant="normal">&#x2216;</mml:mi><mml:mo fence="false" stretchy="false">{</mml:mo><mml:mi>a</mml:mi><mml:mo fence="false" stretchy="false">}</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>&#x222A;</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mi mathvariant="bold">U</mml:mi></mml:mrow><mml:mo>&#x00D7;</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mi mathvariant="script">F</mml:mi></mml:mrow><mml:mi mathvariant="normal">&#x2216;</mml:mi><mml:mo fence="false" stretchy="false">{</mml:mo><mml:mi>b</mml:mi><mml:mo fence="false" stretchy="false">}</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd></mml:mtd><mml:mtd><mml:mi></mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mi mathvariant="bold">U</mml:mi></mml:mrow><mml:mo>&#x00D7;</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mi mathvariant="script">F</mml:mi></mml:mrow><mml:mi mathvariant="normal">&#x2216;</mml:mi><mml:mo fence="false" stretchy="false">{</mml:mo><mml:mi>a</mml:mi><mml:mo fence="false" stretchy="false">}</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>&#x222A;</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mi mathvariant="script">F</mml:mi></mml:mrow><mml:mi mathvariant="normal">&#x2216;</mml:mi><mml:mo fence="false" stretchy="false">{</mml:mo><mml:mi>b</mml:mi><mml:mo fence="false" stretchy="false">}</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd></mml:mtd><mml:mtd><mml:mi></mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mi mathvariant="bold">U</mml:mi></mml:mrow><mml:mo>&#x00D7;</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mi mathvariant="script">F</mml:mi></mml:mrow><mml:mi mathvariant="normal">&#x2216;</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mo fence="false" stretchy="false">{</mml:mo><mml:mi>a</mml:mi><mml:mo fence="false" stretchy="false">}</mml:mo><mml:mo>&#x2229;</mml:mo><mml:mo fence="false" stretchy="false">{</mml:mo><mml:mi>b</mml:mi><mml:mo fence="false" stretchy="false">}</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd></mml:mtd><mml:mtd><mml:mi></mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mi mathvariant="bold">U</mml:mi></mml:mrow><mml:mo>&#x00D7;</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mi mathvariant="script">F</mml:mi></mml:mrow><mml:mi mathvariant="normal">&#x2216;</mml:mi><mml:mi>&#x2205;</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:mi mathvariant="bold">U</mml:mi></mml:mrow><mml:mo>&#x00D7;</mml:mo><mml:mrow><mml:mi mathvariant="script">F</mml:mi></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula></p>
<p>Therefore, the conclusion reduces to <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathbf{U} \times \mathcal{F \subseteq \mathbf{U} \times \mathcal{F$]]></texMath></inlineMaths>.</p></list-item>
<list-item><p><b>Case</b> <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathrm{RHS} = \{\,a: \tau_1\,\} \sqcup \tau_2 &#x2192; \tau_3$]]></texMath></inlineMaths>. Then the RHS is mapped to <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$(\mathbf{U} \times (\mathcal{F \setminus \br{\hspace{.1em}{a}\hspace{.1em}})) \cup (\mathbf{U} \times \mathcal{F) = \mathbf{U} \times \mathcal{F$]]></texMath></inlineMaths> and the conclusion reduces to <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathbf{U} \times \mathcal{F \subseteq \mathbf{U} \times \mathcal{F$]]></texMath></inlineMaths>.</p></list-item>
</list>
<statement id="def-4_6">
<label>Definition 4.6</label>
<p>The Boolean homomorphism <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{J{[|\cdot|]}_a^T$]]></texMath></inlineMaths> from the Boolean algebra of types ordered by subtyping under the context <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\Sigma$]]></texMath></inlineMaths> to the Boolean algebra of types ordered by subtyping under the context <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\lhd \Sigma$]]></texMath></inlineMaths> is defined as:</p>
</statement>
<disp-formula id="eqn"><label></label><mml:math display='block'><mml:mtable displaystyle="true" columnalign="right left" columnspacing="0em" rowspacing="3pt" name="aligned"><mml:mtr><mml:mtd><mml:mrow><mml:mi mathvariant="script">J</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">[</mml:mo></mml:mrow><mml:msub><mml:mi>&#x03C4;</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">&#x2192;</mml:mo><mml:msub><mml:mi>&#x03C4;</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:msubsup><mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msubsup></mml:mtd><mml:mtd><mml:mi></mml:mi><mml:mo>=</mml:mo><mml:mi mathvariant="normal">&#x22A4;</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mi mathvariant="script">J</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">[</mml:mo></mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:msup><mml:mi>a</mml:mi><mml:mrow><mml:mi>&#x2032;</mml:mi></mml:mrow></mml:msup><mml:mo>:</mml:mo><mml:msub><mml:mi>&#x03C4;</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>}</mml:mo></mml:mrow><mml:msubsup><mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msubsup></mml:mtd><mml:mtd><mml:mi></mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mtable columnalign="left left" columnspacing="1em" rowspacing="4pt" name="array"><mml:mtr><mml:mtd><mml:msub><mml:mi>&#x03C4;</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:mtext>&#x00A0;if&#x00A0;</mml:mtext><mml:mi>a</mml:mi><mml:mo>=</mml:mo><mml:msup><mml:mi>a</mml:mi><mml:mrow><mml:mi>&#x2032;</mml:mi></mml:mrow></mml:msup></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mi mathvariant="normal">&#x22A4;</mml:mi></mml:mtd><mml:mtd><mml:mtext>&#x00A0;otherwise&#x00A0;</mml:mtext></mml:mtd></mml:mtr></mml:mtable><mml:mstyle scriptlevel="0"><mml:mspace width="1em"></mml:mspace></mml:mstyle><mml:mrow><mml:mi mathvariant="script">J</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">[</mml:mo></mml:mrow><mml:mi mathvariant="normal">#</mml:mi><mml:msup><mml:mi>T</mml:mi><mml:mrow><mml:mi>&#x2032;</mml:mi></mml:mrow></mml:msup><mml:msubsup><mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mrow><mml:mi>a</mml:mi></mml:mrow><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msubsup><mml:mo>=</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mtable columnalign="left left" columnspacing="1em" rowspacing=".2em"><mml:mtr><mml:mtd><mml:mi mathvariant="normal">&#x22A4;</mml:mi></mml:mtd><mml:mtd><mml:mtext>&#x00A0;if&#x00A0;</mml:mtext><mml:mi>T</mml:mi><mml:mo>&#x2264;</mml:mo><mml:msup><mml:mi>T</mml:mi><mml:mrow><mml:mi>&#x2032;</mml:mi></mml:mrow></mml:msup></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo>&#x22A5;</mml:mo></mml:mtd><mml:mtd><mml:mtext>&#x00A0;otherwise&#x00A0;</mml:mtext></mml:mtd></mml:mtr></mml:mtable><mml:mo fence="true" stretchy="true" symmetric="true"></mml:mo></mml:mrow><mml:mo fence="true" stretchy="true" symmetric="true"></mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula>
<p>We may pick a dummy tag unrelated to any other tags for <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T$]]></texMath></inlineMaths>, in which case we denote the resulting homomorphism as <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{J{[|\cdot|]}_a$]]></texMath></inlineMaths>:</p>
<disp-formula id="eqn"><label></label><mml:math display='block'><mml:mrow><mml:mi mathvariant="script">J</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">[</mml:mo></mml:mrow><mml:msub><mml:mi>&#x03C4;</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">&#x2192;</mml:mo><mml:msub><mml:mi>&#x03C4;</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mrow><mml:mi>a</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi mathvariant="normal">&#x22A4;</mml:mi><mml:mstyle scriptlevel="0"><mml:mspace width="1em"></mml:mspace></mml:mstyle><mml:mrow><mml:mi mathvariant="script">J</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">[</mml:mo></mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:msup><mml:mi>a</mml:mi><mml:mrow><mml:mi>&#x2032;</mml:mi></mml:mrow></mml:msup><mml:mo>:</mml:mo><mml:msub><mml:mi>&#x03C4;</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>}</mml:mo></mml:mrow><mml:msub><mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mrow><mml:mi>a</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mtable columnalign="left left" columnspacing="1em" rowspacing="4pt"><mml:mtr><mml:mtd><mml:msub><mml:mi>&#x03C4;</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:mtext>&#x00A0;if&#x00A0;</mml:mtext><mml:mi>a</mml:mi><mml:mo>=</mml:mo><mml:msup><mml:mi>a</mml:mi><mml:mrow><mml:mi>&#x2032;</mml:mi></mml:mrow></mml:msup></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mi mathvariant="normal">&#x22A4;</mml:mi></mml:mtd><mml:mtd><mml:mtext>&#x00A0;otherwise&#x00A0;</mml:mtext></mml:mtd></mml:mtr></mml:mtable><mml:mstyle scriptlevel="0"><mml:mspace width="1em"></mml:mspace></mml:mstyle><mml:mrow><mml:mi mathvariant="script">J</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">[</mml:mo></mml:mrow><mml:mi mathvariant="normal">#</mml:mi><mml:msup><mml:mi>T</mml:mi><mml:mrow><mml:mi>&#x2032;</mml:mi></mml:mrow></mml:msup><mml:msub><mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mrow><mml:mi>a</mml:mi></mml:mrow></mml:msub><mml:mo>=&#x22A5;</mml:mo><mml:mo fence="true" stretchy="true" symmetric="true"></mml:mo></mml:mrow></mml:math></disp-formula>
<statement id="lem-4_7">
<label>Lemma 4.7</label>
<p><inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{J{[|\cdot|]}_a^T$]]></texMath></inlineMaths> is monotonic.</p>
</statement>
<p>P<sc>roof</sc>.   We show by case analysis on unassuming subtyping derivations that the subtyping relation is compatible with <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{J{[|\cdot|]}_a^T$]]></texMath></inlineMaths>. The non-trivial cases are S-T<sc>ag</sc>S<sc>ub</sc>}, S-T<sc>ag</sc>B<sc>ot</sc>}, S-R<sc>cd</sc>D<sc>epth</sc>}, and S-R<sc>cd</sc>T<sc>op</sc>}.</p>

<list>
<list-item><p><b>Case S-T<sc>ag</sc>S<sc>ub</sc>.</b> The rule has premise <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T_1 \preceq T_2$]]></texMath></inlineMaths> and conclusion <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[${\#}{T_1} =< {\#}{T_2}$]]></texMath></inlineMaths>. We proceed by case analysis of the subtag relation of <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T_1$]]></texMath></inlineMaths> and <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T_2$]]></texMath></inlineMaths> with <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T$]]></texMath></inlineMaths>.</p>
<list-item><p><b>Case</b> <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T \preceq T_1$]]></texMath></inlineMaths>. Then we also have <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T \preceq T_2$]]></texMath></inlineMaths> by transitivity of inheritance and the conclusion maps to <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\top =< \top$]]></texMath></inlineMaths>.</p></list-item>
<list-item><p><b>Case</b> <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T \not\preceq T_1$]]></texMath></inlineMaths> <b>and</b> <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T \preceq T_2$]]></texMath></inlineMaths>. Then the conclusion maps to <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\bot =< \top$]]></texMath></inlineMaths>.</p></list-item>
<list-item><p><b>Case</b> <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T \not\preceq T_1$]]></texMath></inlineMaths> and <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T \not\preceq T_2$]]></texMath></inlineMaths>. Then the conclusion maps to <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\bot =< \bot$]]></texMath></inlineMaths>.</p></list-item>
<list-item><p><b>Case S-T<sc>ag</sc>B<sc>ot</sc>.</b> The rule has premises <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T_2 \not\preceq T_1$]]></texMath></inlineMaths> and <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T_1 \not\preceq T_2$]]></texMath></inlineMaths>, i.e., <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T_1$]]></texMath></inlineMaths> and <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T_2$]]></texMath></inlineMaths> are unrelated, and conclusion <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[${\#}{T_1} \sqcap {\#}{T_2} =< \bot$]]></texMath></inlineMaths>. If either one of <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T_1$]]></texMath></inlineMaths> or <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T_2$]]></texMath></inlineMaths> maps to <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\top$]]></texMath></inlineMaths>, meaning that it is a supertag of <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T$]]></texMath></inlineMaths>, the other one cannot also be a supertag of <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T$]]></texMath></inlineMaths> without the two being related due to single-inheritance. Therefore one of <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[${\#}{T_1}$]]></texMath></inlineMaths> and <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[${\#}{T_2}$]]></texMath></inlineMaths> must map to <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\bot$]]></texMath></inlineMaths> and the conclusion reduces to <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\bot =< \bot$]]></texMath></inlineMaths>.</p></list-item>
<list-item><p><b>Case S-R<sc>cd</sc>D<sc>epth</sc>.</b> The rule has premise <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\lhd \Sigma |- \tau_1 =< \tau_2$]]></texMath></inlineMaths> and conclusion <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\Sigma |- \{\,a: \tau_1\,\} =< \{\,a: \tau_2\,\}$]]></texMath></inlineMaths> for some <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$a$]]></texMath></inlineMaths>, <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau_1$]]></texMath></inlineMaths>, and <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau_2$]]></texMath></inlineMaths>.</p>
<list-item><p><b>Case</b> <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$a = a'$]]></texMath></inlineMaths>. Then the conclusion maps to <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\lhd \Sigma |- \tau_1 =< \tau_2$]]></texMath></inlineMaths>, which we have as the premise of the rule.</p></list-item>
<list-item><p><b>Case</b> <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$a \neq a'$]]></texMath></inlineMaths>. Then the conclusion maps to <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\lhd \Sigma |- \top =< \top$]]></texMath></inlineMaths>.</p></list-item>
<list-item><p><b>Case S-R</b><sc><b>cd</b></sc><b>T</b><sc><b>op</b></sc>.</p>
<list>
<list-item><p><b>Case</b> <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathrm{RHS} = \{\,a': \tau_1\,\} \sqcup \rcd{b^{\neq a'}: \tau_2}$]]></texMath></inlineMaths>. Since <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$b \neq a'$]]></texMath></inlineMaths>, we must have either <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$a \neq a'$]]></texMath></inlineMaths> or <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$a \neq b$]]></texMath></inlineMaths>. Then either <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\{\,a': \tau_1\,\}$]]></texMath></inlineMaths> or <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\{\,b: \tau_2\,\}$]]></texMath></inlineMaths> maps to <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\top$]]></texMath></inlineMaths> and the conclusion reduces to <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\top =< \top$]]></texMath></inlineMaths>.</p></list-item>
<list-item><p><b>Case</b> <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathrm{RHS} = \{\,a': \tau_1\,\} \sqcup \tau_2 &#x2192; \tau_3$]]></texMath></inlineMaths>. Then the RHS is mapped to <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{J{[|\{\,a': \tau_1\,\}|]}_a^T \sqcup \top = \top$]]></texMath></inlineMaths> and the conclusion reduces to <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\top =< \top$]]></texMath></inlineMaths>.</p></list-item>
</list-item>
</list>
</list>

<statement id="rmk-4_2">
<title>Remark 4.2.</title>
<p>This homomorphism ensures that when two record types are in a subtyping relationship and share a field, they have compatible types for this field; it is a crucial ingredient in allowing our semantic proof to be simple and concise. Again, the presence of a rule like <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\{ a : \bot \} \leqslant \bot$]]></texMath></inlineMaths>, discussed in Section 4.4, would preclude this approach, as it would require that <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{J{[|\{\,a': \bot\,\}|]}_a^T =< \mathcal{J{[|\bot|]}_a^T = \bot$]]></texMath></inlineMaths>. Indeed, this would mean that when <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$a&#x2019; \neq a$]]></texMath></inlineMaths>, S-R<sc>cd</sc>T<sc>op</sc>} would require that <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{J{[|\top|]}_a^T = \top =< \mathcal{J{[|\{\,a: \tau\,\} \sqcup \{\,a': \bot\,\}|]}_a^T = \mathcal{J{[|\{\,a: \tau\,\}|]}_a^T \sqcup \mathcal{J{[|\{\,a': \bot\,\}|]}_a^T = \mathcal{J{[|\{\,a: \tau\,\}|]}_a^T \sqcup \bot == \mathcal{J{[|\{\,a: \tau\,\}|]}_a^T$]]></texMath></inlineMaths>, which would require us to make <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{J{[|\{\,a: \tau\,\}|]}_a^T$]]></texMath></inlineMaths> equivalent to <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\top$]]></texMath></inlineMaths>, preventing us from easily teasing apart the type of a field <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$x$]]></texMath></inlineMaths> from the rest of a type expression. This is also the place that would break when adding rules like <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$(\tau_1&#x2192;\tau_2)\sqcap\{\,a:\tau_3\,\} =< \bot$]]></texMath></inlineMaths> and <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\top =< \textit{T}\sqcup\{\,a:\tau_3\,\}$]]></texMath></inlineMaths>: due to S-R<sc>cd</sc>T<sc>op</sc>} and S-T<sc>ag</sc>B<sc>ot</sc>}, such additions would again prevent us from projecting away to either <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\top$]]></texMath></inlineMaths> or <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\bot$]]></texMath></inlineMaths> the type components we do not want to focus on.</p>
</statement>
<p>Notice that this homomorphism (together with <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{D{[|\cdot|]}^{&#x2192;}_T$]]></texMath></inlineMaths> and <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{C{[|\cdot|]}_{&#x2192;}^T$]]></texMath></inlineMaths> defined below) maps types to the codomain of types. In the presence of type variables and recursive types, the inlining performed by Corollary 3.4 may result in types that are larger than the input types. However, as our coinductive reasoning does not rely on trees being smaller, we can safely apply the homomorphisms on the larger types.</p>
<statement id="def-4_8">
<title>Definition 4.8.</title>
<p>The Boolean homomorphism <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{D{[|\cdot|]}^{&#x2192;}_T$]]></texMath></inlineMaths> from the Boolean algebra of types ordered by subtyping under the context <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\Sigma$]]></texMath></inlineMaths> to the Boolean algebra of types ordered by subtyping under the context <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\lhd \Sigma$]]></texMath></inlineMaths>, is defined similarly to \ref{def:rcdfldcls-homomorphism} but with a negation due to function contravariance, as:</p>
<disp-formula id="eqn"><label></label><mml:math display='block'><mml:mtable columnalign="left left" columnspacing="1em" rowspacing="4pt" name="array"><mml:mtr><mml:mtd><mml:mrow><mml:mi mathvariant="script">D</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">[</mml:mo></mml:mrow><mml:msub><mml:mi>&#x03C4;</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">&#x2192;</mml:mo><mml:msub><mml:mi>&#x03C4;</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mrow><mml:mover><mml:mi>T</mml:mi><mml:mo stretchy="false">&#x2192;</mml:mo></mml:mover></mml:mrow><mml:mo>=</mml:mo><mml:mi mathvariant="normal">&#x00AC;</mml:mi><mml:msub><mml:mi>&#x03C4;</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:mrow><mml:mi mathvariant="script">D</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">[</mml:mo></mml:mrow><mml:mi mathvariant="normal">#</mml:mi><mml:msup><mml:mi>T</mml:mi><mml:mrow><mml:mi>&#x2032;</mml:mi></mml:mrow></mml:msup><mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mrow><mml:mover><mml:mi>T</mml:mi><mml:mo stretchy="false">&#x2192;</mml:mo></mml:mover></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mtable columnalign="left left" columnspacing="1em" rowspacing=".2em"><mml:mtr><mml:mtd><mml:mi mathvariant="normal">&#x22A4;</mml:mi></mml:mtd><mml:mtd><mml:mtext>&#x00A0;if&#x00A0;</mml:mtext><mml:mi>T</mml:mi><mml:mo>&#x2264;</mml:mo><mml:msup><mml:mi>T</mml:mi><mml:mrow><mml:mi>&#x2032;</mml:mi></mml:mrow></mml:msup></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mi mathvariant="script">D</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">[</mml:mo></mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mi>a</mml:mi><mml:mo>:</mml:mo><mml:msub><mml:mi>&#x03C4;</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>}</mml:mo></mml:mrow><mml:msub><mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi mathvariant="normal">&#x22A4;</mml:mi></mml:mtd><mml:mtd><mml:mtext>&#x00A0;otherwise&#x00A0;</mml:mtext></mml:mtd></mml:mtr></mml:mtable><mml:mo fence="true" stretchy="true" symmetric="true"></mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula>
<p>We may pick a dummy tag unrelated to any other tags for <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T$]]></texMath></inlineMaths>, in which case we denote the resulting homomorphism as <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{D{[|\cdot|]}^{&#x2192;}$]]></texMath></inlineMaths>:</p>
<disp-formula id="eqn"><label></label><mml:math display='block'><mml:mrow><mml:mi mathvariant="script">D</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">[</mml:mo></mml:mrow><mml:msub><mml:mi>&#x03C4;</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">&#x2192;</mml:mo><mml:msub><mml:mi>&#x03C4;</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mo stretchy="false">&#x2192;=</mml:mo><mml:mi mathvariant="normal">&#x00AC;</mml:mi><mml:msub><mml:mi>&#x03C4;</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mstyle scriptlevel="0"><mml:mspace width="1em"></mml:mspace></mml:mstyle><mml:mrow><mml:mi mathvariant="script">D</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">[</mml:mo></mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mi>a</mml:mi><mml:mo>:</mml:mo><mml:msub><mml:mi>&#x03C4;</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>}</mml:mo></mml:mrow><mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mover><mml:mstyle scriptlevel="0"><mml:mo>&#x2192;</mml:mo></mml:mstyle><mml:mpadded width="+0.833em" lspace="0.278em" voffset="-.2em" height="-.2em"><mml:mo stretchy="false">&#x2192;</mml:mo><mml:mspace depth=".25em"></mml:mspace></mml:mpadded></mml:mover><mml:mo>=</mml:mo><mml:mi mathvariant="normal">&#x22A4;</mml:mi><mml:mstyle scriptlevel="0"><mml:mspace width="1em"></mml:mspace></mml:mstyle><mml:mrow><mml:mi mathvariant="script">D</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">[</mml:mo></mml:mrow><mml:mi mathvariant="normal">#</mml:mi><mml:msup><mml:mi>T</mml:mi><mml:mrow><mml:mi>&#x2032;</mml:mi></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mrow><mml:mo stretchy="false">&#x2192;</mml:mo></mml:mrow></mml:msup><mml:mo>=&#x22A5;</mml:mo></mml:math></disp-formula>
<statement id="lem-4_9">
<title>Lemma 4.9.</title>
<p><inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{D{[|\cdot|]}^{&#x2192;}_T$]]></texMath></inlineMaths> is <i>monotonic</i>.</p>
</statement>
<p>P<sc>roof</sc>.  We show by case analysis on unassuming subtyping derivations that the subtyping relation is compatible with <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{D{[|\cdot|]}^{&#x2192;}_T$]]></texMath></inlineMaths>. The non-trivial cases are S-T<sc>ag</sc>S<sc>ub</sc>}, S-T<sc>ag</sc>B<sc>ot</sc>}, S-F<sc>un</sc>D<sc>epth</sc>}, and S-R<sc>cd</sc>T<sc>op</sc>}.</p>
<list>
<list-item><p>Case S-T<sc>ag</sc>S<sc>ub</sc>. The rule has premise <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T_1 \preceq T_2$]]></texMath></inlineMaths> and conclusion <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[${\#}{T_1} =< {\#}{T_2}$]]></texMath></inlineMaths>. We proceed by case analysis of the subtag relation of <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T_1$]]></texMath></inlineMaths> and <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T_2$]]></texMath></inlineMaths> with <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T$]]></texMath></inlineMaths>.</p>
<list-item><p><b>Case</b> <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T \preceq T_1$]]></texMath></inlineMaths>. Then we also have <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T \preceq T_2$]]></texMath></inlineMaths> by transitivity of inheritance and the conclusion maps to <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\top =< \top$]]></texMath></inlineMaths>.</p></list-item>
<list-item><p><b>Case</b> <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T \not\preceq T_1$]]></texMath></inlineMaths> and <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T \preceq T_2$]]></texMath></inlineMaths>. Then the conclusion maps to <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\bot =< \top$]]></texMath></inlineMaths>.</p></list-item>
<list-item><p><b>Case</b> <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T \not\preceq T_1$]]></texMath></inlineMaths> and <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T \not\preceq T_2$]]></texMath></inlineMaths>. Then the conclusion maps to <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\bot =< \bot$]]></texMath></inlineMaths>.</p></list-item></list-item>
<list-item><p>Case S-T<sc>ag</sc>B<sc>ot</sc>. The rule has premises <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T_2 \not\preceq T_1$]]></texMath></inlineMaths> and <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T_1 \not\preceq T_2$]]></texMath></inlineMaths>, i.e., <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T_1$]]></texMath></inlineMaths> and <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T_2$]]></texMath></inlineMaths> are unrelated, and conclusion <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[${\#}{T_1} \sqcap {\#}{T_2} =< \bot$]]></texMath></inlineMaths>. If either one of <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T_1$]]></texMath></inlineMaths> or <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T_2$]]></texMath></inlineMaths> maps to <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\top$]]></texMath></inlineMaths>, meaning that it is a supertag of <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T$]]></texMath></inlineMaths>, the other one cannot also be a supertag of <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T$]]></texMath></inlineMaths> without the two being related due to single-inheritance. Therefore one of <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[${\#}{T_1}$]]></texMath></inlineMaths> and <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[${\#}{T_2}$]]></texMath></inlineMaths> must map to <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\bot$]]></texMath></inlineMaths> and the conclusion reduces to <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\bot =< \bot$]]></texMath></inlineMaths>.</p></list-item>
<list-item><p>Case S-F<sc>un</sc>D<sc>epth</sc>. The rule has premises <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\lhd \Sigma |- \tau_0 =< \tau_1$]]></texMath></inlineMaths> and <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\lhd \Sigma |- \tau_2 =< \tau_3$]]></texMath></inlineMaths> and conclusion <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\Sigma |- \tau_1 &#x2192; \tau_2 =< \tau_0 &#x2192; \tau_3$]]></texMath></inlineMaths> for some <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau_0$]]></texMath></inlineMaths>, <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau_1$]]></texMath></inlineMaths>, <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau_2$]]></texMath></inlineMaths>, and <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau_3$]]></texMath></inlineMaths>. Then the conclusion maps to <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\lhd \Sigma |- \neg \tau_1 =< \neg \tau_0$]]></texMath></inlineMaths>, which holds by S-N<sc>eg</sc>I<sc>nv</sc>} on the first premise.</p></list-item>
</list>
</statement>
<statement id="def-4_10">
<title>Definition 4.10.</title>
<p>The Boolean homomorphism <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{C{[|\cdot|]}_{&#x2192;}^T$]]></texMath></inlineMaths> from the Boolean algebra of types ordered by subtyping under the context <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\Sigma$]]></texMath></inlineMaths> to the Boolean algebra of types ordered by subtyping under the context <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\lhd \Sigma$]]></texMath></inlineMaths>, given by:</p>
<p><disp-formula id="eqn"><label></label><mml:math display='block'><mml:mtable columnalign="left left" columnspacing="1em" rowspacing="4pt" name="array"><mml:mtr><mml:mtd><mml:mrow><mml:mi mathvariant="script">D</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">[</mml:mo></mml:mrow><mml:msub><mml:mi>&#x03C4;</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">&#x2192;</mml:mo><mml:msub><mml:mi>&#x03C4;</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mrow><mml:mover><mml:mi>T</mml:mi><mml:mo stretchy="false">&#x2192;</mml:mo></mml:mover></mml:mrow><mml:mo>=</mml:mo><mml:mi mathvariant="normal">&#x00AC;</mml:mi><mml:msub><mml:mi>&#x03C4;</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:mrow><mml:mi mathvariant="script">D</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">[</mml:mo></mml:mrow><mml:mi mathvariant="normal">#</mml:mi><mml:msup><mml:mi>T</mml:mi><mml:mrow><mml:mi>&#x2032;</mml:mi></mml:mrow></mml:msup><mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mrow><mml:mover><mml:mi>T</mml:mi><mml:mo stretchy="false">&#x2192;</mml:mo></mml:mover></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mtable columnalign="left left" columnspacing="1em" rowspacing=".2em"><mml:mtr><mml:mtd><mml:mi mathvariant="normal">&#x22A4;</mml:mi></mml:mtd><mml:mtd><mml:mtext>&#x00A0;if&#x00A0;</mml:mtext><mml:mi>T</mml:mi><mml:mo>&#x2264;</mml:mo><mml:msup><mml:mi>T</mml:mi><mml:mrow><mml:mi>&#x2032;</mml:mi></mml:mrow></mml:msup></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mi mathvariant="script">D</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">[</mml:mo></mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mi>a</mml:mi><mml:mo>:</mml:mo><mml:msub><mml:mi>&#x03C4;</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>}</mml:mo></mml:mrow><mml:msub><mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mi mathvariant="normal">&#x22A4;</mml:mi></mml:mtd><mml:mtd><mml:mtext>&#x00A0;otherwise&#x00A0;</mml:mtext></mml:mtd></mml:mtr></mml:mtable><mml:mo fence="true" stretchy="true" symmetric="true"></mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula></p>
<p>We may pick a dummy tag unrelated to any other tags for <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T$]]></texMath></inlineMaths>, in which case we denote the resulting homomorphism as <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{C{[|\cdot|]}_{&#x2192;}$]]></texMath></inlineMaths>:</p>
<disp-formula id="eqn"><label></label><mml:math display='block'><mml:mrow><mml:mi mathvariant="script">D</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">[</mml:mo></mml:mrow><mml:msub><mml:mi>&#x03C4;</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">&#x2192;</mml:mo><mml:msub><mml:mi>&#x03C4;</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mo stretchy="false">&#x2192;=</mml:mo><mml:mi mathvariant="normal">&#x00AC;</mml:mi><mml:msub><mml:mi>&#x03C4;</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mstyle scriptlevel="0"><mml:mspace width="1em"></mml:mspace></mml:mstyle><mml:mrow><mml:mi mathvariant="script">D</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">[</mml:mo></mml:mrow><mml:mrow><mml:mo>{</mml:mo><mml:mi>a</mml:mi><mml:mo>:</mml:mo><mml:msub><mml:mi>&#x03C4;</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>}</mml:mo></mml:mrow><mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mover><mml:mstyle scriptlevel="0"><mml:mo>&#x2192;</mml:mo></mml:mstyle><mml:mpadded width="+0.833em" lspace="0.278em" voffset="-.2em" height="-.2em"><mml:mo stretchy="false">&#x2192;</mml:mo><mml:mspace depth=".25em"></mml:mspace></mml:mpadded></mml:mover><mml:mo>=</mml:mo><mml:mi mathvariant="normal">&#x22A4;</mml:mi><mml:mstyle scriptlevel="0"><mml:mspace width="1em"></mml:mspace></mml:mstyle><mml:mrow><mml:mi mathvariant="script">D</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">[</mml:mo></mml:mrow><mml:mi mathvariant="normal">#</mml:mi><mml:msup><mml:mi>T</mml:mi><mml:mrow><mml:mi>&#x2032;</mml:mi></mml:mrow></mml:msup><mml:msup><mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mrow><mml:mo stretchy="false">&#x2192;</mml:mo></mml:mrow></mml:msup><mml:mo>=&#x22A5;</mml:mo></mml:math></disp-formula>
<statement id="lem-4_11">
<title>Lemma 4.11.</title>
<p><inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{C{[|\cdot|]}_{&#x2192;}^T$]]></texMath></inlineMaths> is monotonic.</p>
</statement>
<p>P<sc>roof</sc>.   We show by case analysis on unassuming subtyping derivations that the subtyping relation is compatible with <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{C{[|\cdot|]}_{&#x2192;}^T$]]></texMath></inlineMaths>. The non-trivial cases are S-T<sc>ag</sc>S<sc>ub</sc>}, S-T<sc>ag</sc>B<sc>ot</sc>}, S-F<sc>un</sc>D<sc>epth</sc>}, and S-R<sc>cd</sc>T<sc>op</sc>}.</p>
<list>
<list-item><p>Cases S-T<sc>ag</sc>S<sc>ub</sc>}, S-T<sc>ag</sc>B<sc>ot</sc>. The proof for these two cases are identical to the respective cases for <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{D{[|\cdot|]}^{&#x2192;}_T$]]></texMath></inlineMaths> above.</p><list-item>
<list-item><p>Case S-F<sc>un</sc>D<sc>epth</sc>. The rule has premises <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\lhd \Sigma |- \tau_0 =< \tau_1$]]></texMath></inlineMaths> and <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\lhd \Sigma |- \tau_2 =< \tau_3$]]></texMath></inlineMaths> and conclusion <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\Sigma |- \tau_1 &#x2192; \tau_2 =< \tau_0 &#x2192; \tau_3$]]></texMath></inlineMaths> for some <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau_0$]]></texMath></inlineMaths>, <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau_1$]]></texMath></inlineMaths>, <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau_2$]]></texMath></inlineMaths>, and <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau_3$]]></texMath></inlineMaths>. Then the conclusion maps to <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\lhd \Sigma |- \tau_2 =< \tau_3$]]></texMath></inlineMaths>, which we have as the premise of the rule.</p></list-item>
</list>
</sec>
<sec id="sec">
<label>4.5</label>
<title>Subtyping Soundness by Homomorphisms</title>
<p>We can now state the key lemma that allows us to prove soundness of subtyping. It is similar to Theorem 4.1 except that it works on guarded subtyping contexts <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\rhd\mathcal{B}$]]></texMath></inlineMaths>:</p>
<statement id="lem-4_12">
<label>Lemma 4.12.</label>
<title>Subtyping soundness</title>
<p>If <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\rhd\mathcal{B} |- \tau =< \pi$]]></texMath></inlineMaths>, where:</p>
<disp-formula id="eqn"><label></label><mml:math display='block'><mml:mi>&#x03C4;</mml:mi><mml:mo>&#x2208;</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mo>&#x22A5;</mml:mo><mml:mo>,</mml:mo><mml:mi mathvariant="normal">&#x22A4;</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>&#x03C4;</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">&#x2192;</mml:mo><mml:msub><mml:mi>&#x03C4;</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>T</mml:mi><mml:mrow><mml:mo>{</mml:mo><mml:msup><mml:mrow><mml:mover><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>:</mml:mo><mml:msub><mml:mi>&#x03C4;</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo accent="true">&#x2015;</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup><mml:mo>}</mml:mo></mml:mrow><mml:mo>}</mml:mo></mml:mrow><mml:mstyle scriptlevel="0"><mml:mspace width="1em"></mml:mspace></mml:mstyle><mml:mi>&#x03C0;</mml:mi><mml:mo>&#x2208;</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mo>&#x22A5;</mml:mo><mml:mo>,</mml:mo><mml:mi mathvariant="normal">&#x22A4;</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>&#x03C0;</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">&#x2192;</mml:mo><mml:msub><mml:mi>&#x03C0;</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi mathvariant="normal">#</mml:mi><mml:msup><mml:mi>T</mml:mi><mml:mrow><mml:mi>&#x2032;</mml:mi></mml:mrow></mml:msup><mml:mo>,</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:msup><mml:mi>a</mml:mi><mml:mrow><mml:mi>&#x2032;</mml:mi></mml:mrow></mml:msup><mml:mo>:</mml:mo><mml:msub><mml:mi>&#x03C0;</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>}</mml:mo></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:math></disp-formula>
<p><i>then exactly one of the following is true:</i></p>
<list>
<list-item><p><inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau = \bot$]]></texMath></inlineMaths> or <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\pi = \top$]]></texMath></inlineMaths>;</p></list-item>
<list-item><p><inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau = \tau_1&#x2192;\tau_2$]]></texMath></inlineMaths> and <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\pi = \pi_1&#x2192;\pi_2$]]></texMath></inlineMaths> and <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{B} |- \pi_1 =< \tau_1$]]></texMath></inlineMaths> and <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{B} |- \tau_2 =< \pi_2$]]></texMath></inlineMaths>;</p></list-item>
<list-item><p><inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau = \obj{T}{\overline{a_i:\tau_i}^i}$]]></texMath></inlineMaths> and <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\pi = {\#}{T'}$]]></texMath></inlineMaths>   and <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T \preceq T'$]]></texMath></inlineMaths>;</p></list-item>
<list-item><p><inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau = \obj{T}{\overline{a_i:\tau_i}^i}$]]></texMath></inlineMaths> and <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\pi = \{\,a_k:\pi_1\,\}$]]></texMath></inlineMaths>  and <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{B} |- \tau_k =< \pi_1$]]></texMath></inlineMaths> for some <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$k$]]></texMath></inlineMaths>.</p></list-item>
</list>
<p>P<sc>roof</sc>. By case analysis on <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau$]]></texMath></inlineMaths> and <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\pi$]]></texMath></inlineMaths>.</p>
<list>
<list-item><p><b>Case</b> <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\pi = \bot$]]></texMath></inlineMaths>.      Consider the Boolean homomorphism <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{H{[|\cdot|]}$]]></texMath></inlineMaths> defined in Definition~\ref{def:funcls-homomorphism}. It is easy to decide the order in the target Boolean algebra, i.e., inclusion of sets. This allows us to rule out the impossible cases.</p></list-item>
<list-item><p><b>Case</b> <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau = \top$]]></texMath></inlineMaths>. Then <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{H{[|\top|]} = \mathbf{U}$]]></texMath></inlineMaths>. This case is impossible since <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathbf{U} \nsubseteq \emptyset$]]></texMath></inlineMaths>.</p></list-item>
<list-item><p><b>Case</b> <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau = \tau_1 &#x2192; \tau_2$]]></texMath></inlineMaths>. Then <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{H{[|\tau_1 &#x2192; \tau_2|]} = \setLitTight{{&#x2192;}}$]]></texMath></inlineMaths>. This case is impossible since <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\setLitTight{{&#x2192;}} \nsubseteq \emptyset$]]></texMath></inlineMaths>.</p></list-item>
<list-item><p><b>Case</b> <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau = \bot$]]></texMath></inlineMaths>. Immediate.</p></list-item>
<list-item><p><b>Case</b> <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau = \obj{T}{\overline{a_i:\tau_i}^i}$]]></texMath></inlineMaths>. Then <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{H{[|\obj{T}{\overline{a_i:\tau_i}^i}|]} = \subclasses\DCtxScript{T}$]]></texMath></inlineMaths>. Since <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T \in \subclasses\DCtxScript{T}$]]></texMath></inlineMaths>, we have <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\subclasses\DCtxScript{T} \nsubseteq \emptyset$]]></texMath></inlineMaths>. Therefore this case is impossible.</p></list-item>
<list-item><p><b>Case</b> <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\pi = \top$]]></texMath></inlineMaths>. Immediate.</p></list-item>
<list-item><p><b>Case</b> <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\pi = {\#}{T'}$]]></texMath></inlineMaths>. Consider the Boolean homomorphism <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{H{[|\cdot|]}$]]></texMath></inlineMaths> defined in Definition~\ref{def:funcls-homomorphism}. It is easy to decide the order in the target Boolean algebra, i.e., inclusion of sets. This allows us to rule out the impossible cases.</p></list-item>
<list-item><p><b>Case</b> <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau = \top$]]></texMath></inlineMaths>. Then <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{H{[|\top|]} = \mathbf{U}$]]></texMath></inlineMaths>. This case is impossible since <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[${&#x2192;} \in \mathbf{U}$]]></texMath></inlineMaths> but <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[${&#x2192;} \notin \subclasses\DCtxScript{{T'}}$]]></texMath></inlineMaths>, which implies <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathbf{U} \nsubseteq \subclasses\DCtxScript{{T'}}$]]></texMath></inlineMaths>.</p></list-item>
<list-item><p><b>Case</b> <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau = \tau_1 &#x2192; \tau_2$]]></texMath></inlineMaths>. Then <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{H{[|\tau_1 &#x2192; \tau_2|]} = \setLitTight{{&#x2192;}}$]]></texMath></inlineMaths>. This case is impossible since <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[${&#x2192;} \notin \subclasses\DCtxScript{{T'}}$]]></texMath></inlineMaths>, which implies <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\setLitTight{{&#x2192;}} \nsubseteq \subclasses\DCtxScript{{T'}}$]]></texMath></inlineMaths>.</p></list-item>
<list-item><p><b>Case</b> <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau = \bot$]]></texMath></inlineMaths>. Immediate</p></list-item>
<list-item><p><b>Case</b> <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau = \obj{T}{\overline{a_i:\tau_i}^i}$]]></texMath></inlineMaths>. % Applying <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{H{[|\cdot|]}$]]></texMath></inlineMaths> to <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\rhd \mathcal{B} |- \obj{T}{\overline{a_i:\tau_i}^i} =< {\#}{T'}$]]></texMath></inlineMaths>, we have <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\subclasses\DCtxScript{T} \subseteq \subclasses\DCtxScript{{T'}}$]]></texMath></inlineMaths>. In particular, we have <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T \in \subclasses\DCtxScript{{T'}}$]]></texMath></inlineMaths>, which implies <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T \preceq T'$]]></texMath></inlineMaths> by the definition of the subtag function.</p></list-item>
</list>
<p>\item[Case <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\pi = \{\,a': \pi_1\,\}$]]></texMath></inlineMaths>.]\ 
	
<list list-type="bullet">
<list-item>We first show that <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau = \obj{T}{\overline{a_i: \tau_i}^i}$]]></texMath></inlineMaths></list-item> and <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$a_k = a'$]]></texMath></inlineMaths> for some <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$k$]]></texMath></inlineMaths> and <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\overline{\tau_i}$]]></texMath></inlineMaths>.</p></list-item>      Consider the Boolean homomorphism <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{I{[|\cdot|]}$]]></texMath></inlineMaths></list-item>      defined in Definition~\ref{def:rcd-homomorphism}.</p></list-item>      It is easy to decide the order in the target Boolean algebra, i.e., inclusion of sets.</p></list-item>      This allows us to rule out the impossible cases.</p></list-item>      \begin{description}</list-item>        \item[Cases <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau = \top$]]></texMath></inlineMaths>, <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau = \tau_1 &#x2192; \tau_2$]]></texMath></inlineMaths>.]</list-item>          Then <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{I{[|\tau|]} = \mathbf{U} \times \mathcal{F$]]></texMath></inlineMaths></list-item>          and <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{I{[|\{\,a': \pi_1\,\}|]} = \mathbf{U} \times (\mathcal{F \setminus \br{\hspace{.1em}{a'}\hspace{.1em}})$]]></texMath></inlineMaths>.</p><p>Since <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$a&#x2019; \in \mathcal{F$]]></texMath></inlineMaths> but <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$a&#x2019; \notin \mathcal{F \setminus \br{\hspace{.1em}{a'}\hspace{.1em}}$]]></texMath></inlineMaths>,</list-item>          we have <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{F \nsubseteq \mathcal{F \setminus \br{\hspace{.1em}{a'}\hspace{.1em}}$]]></texMath></inlineMaths>,</list-item>          which implies <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathbf{U} \times \mathcal{F \nsubseteq \mathbf{U} \times (\mathcal{F \setminus \br{\hspace{.1em}{a'}\hspace{.1em}})$]]></texMath></inlineMaths>.</p><p>Therefore this case is impossible.</p></list-item>
<list-item><p><b>Case</b> <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau = \bot$]]></texMath></inlineMaths>. Immediate.</p></list-item>        \item[Case <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau = \obj{T}{\overline{a_i:\tau_i}^i}$]]></texMath></inlineMaths>.] \hfill</list-item>          \begin{description}</list-item>            \item[Case <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$a&#x2019; \in \setLit{\overline{a_i}^i}$]]></texMath></inlineMaths>.]</list-item>              Then we have <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$a_k = a'$]]></texMath></inlineMaths> for some <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$k$]]></texMath></inlineMaths>.</p>
<list-item><p><b>Case</b> <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$a&#x2019; \notin \setLit{\overline{a_i}^i}$]]></texMath></inlineMaths>. Then <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{I{[|\obj{T}{\overline{a_i:\tau_i}^i}|]}$]]></texMath></inlineMaths> reduces to:</p></list-item>
<disp-formula id="eqn"><label></label><mml:math display='block'><mml:mtable displaystyle="true" columnalign="right left" columnspacing="0em" rowspacing="3pt" name="aligned"><mml:mtr><mml:mtd><mml:mrow><mml:mi mathvariant="script">I</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">[</mml:mo></mml:mrow><mml:mi>T</mml:mi><mml:mrow><mml:mo>{</mml:mo><mml:msup><mml:mrow><mml:mover><mml:mrow><mml:msub><mml:mi>a</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>:</mml:mo><mml:msub><mml:mi>&#x03C4;</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo accent="true">&#x2015;</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup><mml:mo>}</mml:mo></mml:mrow><mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mi></mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo>&#x2264;</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>&#x00D7;</mml:mo><mml:mrow><mml:mi mathvariant="script">F</mml:mi></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo>&#x2229;</mml:mo><mml:munder><mml:mo>&#x22C0;</mml:mo><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:munder><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi mathvariant="bold">U</mml:mi></mml:mrow><mml:mo>&#x00D7;</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi mathvariant="script">F</mml:mi></mml:mrow><mml:mi mathvariant="normal">&#x2216;</mml:mi><mml:mrow><mml:mo>{</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>}</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd></mml:mtd><mml:mtd><mml:mi></mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo>&#x2264;</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>&#x00D7;</mml:mo><mml:mrow><mml:mi mathvariant="script">F</mml:mi></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo>&#x2229;</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi mathvariant="bold">U</mml:mi></mml:mrow><mml:mo>&#x00D7;</mml:mo><mml:munder><mml:mo>&#x22C0;</mml:mo><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:munder><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi mathvariant="script">F</mml:mi></mml:mrow><mml:mi mathvariant="normal">&#x2216;</mml:mi><mml:mrow><mml:mo>{</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>}</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd></mml:mtd><mml:mtd><mml:mi></mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo>&#x2264;</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>&#x00D7;</mml:mo><mml:mrow><mml:mi mathvariant="script">F</mml:mi></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo>&#x2229;</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi mathvariant="bold">U</mml:mi></mml:mrow><mml:mo>&#x00D7;</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi mathvariant="script">F</mml:mi></mml:mrow><mml:mi mathvariant="normal">&#x2216;</mml:mi><mml:munder><mml:mo>&#x22C1;</mml:mo><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:munder><mml:mrow><mml:mo>{</mml:mo><mml:msub><mml:mi>a</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>}</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd></mml:mtd><mml:mtd><mml:mi></mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo>&#x2264;</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>&#x00D7;</mml:mo><mml:mrow><mml:mi mathvariant="script">F</mml:mi></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo>&#x2229;</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi mathvariant="bold">U</mml:mi></mml:mrow><mml:mo>&#x00D7;</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi mathvariant="script">F</mml:mi></mml:mrow><mml:mi mathvariant="normal">&#x2216;</mml:mi><mml:mrow><mml:mo>{</mml:mo><mml:msup><mml:mrow><mml:mover><mml:msub><mml:mi>a</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo accent="true">&#x2015;</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup><mml:mo>}</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd></mml:mtd><mml:mtd><mml:mi></mml:mi><mml:mo>=</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mo>&#x2264;</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>&#x2229;</mml:mo><mml:mrow><mml:mi mathvariant="bold">U</mml:mi></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo>&#x00D7;</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi mathvariant="script">F</mml:mi></mml:mrow><mml:mo>&#x2229;</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi mathvariant="script">F</mml:mi></mml:mrow><mml:mi mathvariant="normal">&#x2216;</mml:mi><mml:mrow><mml:mo>{</mml:mo><mml:msup><mml:mrow><mml:mover><mml:msub><mml:mi>a</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo accent="true">&#x2015;</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup><mml:mo>}</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd></mml:mtd><mml:mtd><mml:mi></mml:mi><mml:mo>=&#x2264;</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>&#x00D7;</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi mathvariant="script">F</mml:mi></mml:mrow><mml:mi mathvariant="normal">&#x2216;</mml:mi><mml:mrow><mml:mo>{</mml:mo><mml:msup><mml:mrow><mml:mover><mml:msub><mml:mi>a</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo accent="true">&#x2015;</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup><mml:mo>}</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula>
<p>We also have <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{I{[|\{\,a': \pi_1\,\}|]} = \mathbf{U} \times (\mathcal{F \setminus \br{\hspace{.1em}{a'}\hspace{.1em}})$]]></texMath></inlineMaths>. Since <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$a&#x2019; \notin \setLit{\overline{a_i}^i}$]]></texMath></inlineMaths>, we have <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$a&#x2019; \in \mathcal{F \setminus \setLit{\overline{a_i}^i}$]]></texMath></inlineMaths> and <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$a&#x2019; \notin \mathcal{F \setminus \br{\,{a'}\,}$]]></texMath></inlineMaths>, which implies <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{F \setminus \setLit{\overline{a_i}^i} \nsubseteq \mathcal{F \setminus \br{\,{a'}\,}$]]></texMath></inlineMaths>, which implies <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathbf{U} \times (\mathcal{F \setminus \setLit{\overline{a_i}^i}) \nsubseteq \mathbf{U} \times (\mathcal{F \setminus \br{\,{a'}\,})$]]></texMath></inlineMaths>. Therefore this case is impossible.</p>
<list-item><p>Consider the Boolean homomorphism <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[${[|\cdot|]}_{a'}^T$]]></texMath></inlineMaths></list-item>      defined in Definition~\ref{def:rcdfldcls-homomorphism}.</p></list-item>      Applying <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[${[|\cdot|]}_{a'}^T$]]></texMath></inlineMaths> to <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\rhd \mathcal{B} |- \obj{T}{\overline{a_i: \tau_i}^i} =< \{\,a': \pi_1\,\}$]]></texMath></inlineMaths>,</list-item>      we have <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{B} |- \tau_k =< \pi_1$]]></texMath></inlineMaths>.</p></list-item>      </list></list-item>    \item[Case <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\pi = \pi_1 &#x2192; \pi_2$]]></texMath></inlineMaths>.] \hfill <list list-type="bullet"></list-item>    <list-item>We first show that <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau = \tau_1 &#x2192; \tau_2$]]></texMath></inlineMaths></list-item>      for some <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau_1$]]></texMath></inlineMaths> and <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau_2$]]></texMath></inlineMaths>.</p></list-item>      Consider the Boolean homomorphism <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{H{[|\cdot|]}$]]></texMath></inlineMaths></list-item>      defined in Definition~\ref{def:funcls-homomorphism}.</p></list-item>      It is easy to decide the order in the target Boolean algebra, i.e., inclusion of sets.</p></list-item>      This allows us to rule out the impossible cases.</p></list-item>      \begin{description}</list-item>        \item[Case <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau = \top$]]></texMath></inlineMaths>.]</list-item>          Then <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{H{[|\top|]} = \mathbf{U}$]]></texMath></inlineMaths>.</p><p>This case is impossible since <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathbf{U} \nsubseteq \setLitTight{{&#x2192;}}$]]></texMath></inlineMaths>.</p></list-item>        \item[Cases <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau = \bot$]]></texMath></inlineMaths>, <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau = \tau_1 &#x2192; \tau_2$]]></texMath></inlineMaths>.] Immediate.</p></list-item>        \item[Case <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau = \obj{T}{\overline{a_i:\tau_i}^i}$]]></texMath></inlineMaths>.]</list-item>          Then <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{H{[|\obj{T}{\overline{a_i:\tau_i}^i}|]} = \subclasses\DCtxScript{T}$]]></texMath></inlineMaths>.</p><p>Since <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T \in \subclasses\DCtxScript{T}$]]></texMath></inlineMaths>,</list-item>          we have <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\subclasses\DCtxScript{T} \nsubseteq \setLitTight{{&#x2192;}}$]]></texMath></inlineMaths>. Therefore this case is impossible.</p>
<list-item>We then show that <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{B} |- \pi_1 =< \tau_1$]]></texMath></inlineMaths>. Consider the Boolean homomorphism <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{D{[|\cdot|]}^{&#x2192;}$]]></texMath></inlineMaths>   defined in Definition~\ref{def:funargcls-homomorphism}.      Applying <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{D{[|\cdot|]}^{&#x2192;}$]]></texMath></inlineMaths> to <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\rhd \mathcal{B} |- \tau_1 &#x2192; \tau_2 =< \pi_1 &#x2192; \pi_2$]]></texMath></inlineMaths>, we have <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{B} |- \neg \tau_1 =< \neg \pi_1$]]></texMath></inlineMaths>,      which implies <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{B} |- \pi_1 =< \tau_1$]]></texMath></inlineMaths> by S-U<sc>niq</sc>C<sc>ompl</sc>}.</p></list-item>
<list-item>We then show that <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{B} |- \tau_2 =< \pi_2$]]></texMath></inlineMaths>.</p></list-item>      Consider the Boolean homomorphism <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{C{[|\cdot|]}_{&#x2192;}$]]></texMath></inlineMaths></list-item>      defined in Definition~\ref{def:funrescls-homomorphism}.</p></list-item>      Applying <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{C{[|\cdot|]}_{&#x2192;}$]]></texMath></inlineMaths> to <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\rhd \mathcal{B} |- \tau_1 &#x2192; \tau_2 =< \pi_1 &#x2192; \pi_2$]]></texMath></inlineMaths>,</list-item>      we have <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{B} |- \tau_2 =< \pi_2$]]></texMath></inlineMaths>.</p></list-item>
</list></list-item>
</list>
</sec>
<sec id="sec5">
<label>5</label>
<title>Completeness of Characteristic Boolean Homomorphisms</title>
<p>In this section, we show that the characteristic Boolean homomorphisms described previously completely characterize Boolean-algebraic subtyping. We also propose a new subtyping decision algorithm but show the problem is co-NP-hard.</p>
<sec id="sec5_1">
<label>5.1</label>
<title>Reduced Disjunctive Normal Forms</title>
<p>It is often useful to massage types into a normal form which we call RDNF, for <italic>reduced disjunctive normal form</italic> [Parreaux and Chau 2022a]. This normal form is similar to a classical disjunctive normal form (DNF) except that we reduce all &#x201C;incompatible&#x201D; intersections and unions to <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\bot$]]></texMath></inlineMaths> and <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\top$]]></texMath></inlineMaths> respectively. Here, <italic>incompatible</italic> means that the type holds no useful information, because it cannot be used meaningfully, as explained in Section 1 and \ifdefined\ExcludeApps the appendix.</p>
<disp-formula id="eqn"><label></label><mml:math display='block'><mml:mtable columnalign="right left" columnspacing="1em" rowspacing="4pt" name="array"><mml:mtr><mml:mtd><mml:mrow><mml:mi mathvariant="normal">D</mml:mi></mml:mrow><mml:mo>::=&#x22A5;&#x2223;</mml:mo><mml:mrow><mml:mi mathvariant="normal">D</mml:mi></mml:mrow><mml:mo>&#x2294;</mml:mo><mml:mrow><mml:mi mathvariant="normal">C</mml:mi></mml:mrow></mml:mtd><mml:mtd><mml:mi>&#x03B1;</mml:mi><mml:mo>&#x231D;</mml:mo><mml:mo>::=</mml:mo><mml:mi>&#x03B1;</mml:mi><mml:mo>&#x2223;</mml:mo><mml:mi mathvariant="normal">&#x00AC;</mml:mi><mml:mi>&#x03B1;</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mi mathvariant="normal">C</mml:mi></mml:mrow><mml:mo>::=</mml:mo><mml:mrow><mml:mi mathvariant="normal">I</mml:mi></mml:mrow><mml:mo>&#x2293;</mml:mo><mml:mi mathvariant="normal">&#x00AC;</mml:mi><mml:mrow><mml:mi mathvariant="normal">U</mml:mi></mml:mrow><mml:mo>&#x2223;</mml:mo><mml:mrow><mml:mi mathvariant="normal">C</mml:mi></mml:mrow><mml:mo>&#x2293;</mml:mo><mml:mi>&#x03B1;</mml:mi><mml:mo>&#x231D;</mml:mo></mml:mtd><mml:mtd><mml:mrow><mml:mi mathvariant="script">N</mml:mi></mml:mrow><mml:mo>::=</mml:mo><mml:mrow><mml:mi mathvariant="normal">T</mml:mi></mml:mrow><mml:mo>&#x2223;</mml:mo><mml:mi mathvariant="normal">#</mml:mi><mml:mi>T</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mi mathvariant="normal">I</mml:mi></mml:mrow><mml:mo>::=</mml:mo><mml:mrow><mml:mi mathvariant="script">N</mml:mi></mml:mrow><mml:mo>&#x2293;</mml:mo><mml:mrow><mml:mi mathvariant="script">F</mml:mi></mml:mrow><mml:mo>&#x2293;</mml:mo><mml:mrow><mml:mi mathvariant="script">R</mml:mi></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mi mathvariant="script">F</mml:mi></mml:mrow><mml:mo>::=</mml:mo><mml:mi mathvariant="normal">&#x22A4;</mml:mi><mml:mo>&#x2223;</mml:mo><mml:mrow><mml:mi mathvariant="normal">D</mml:mi></mml:mrow><mml:mo stretchy="false">&#x2192;</mml:mo><mml:mrow><mml:mi mathvariant="normal">D</mml:mi></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mi mathvariant="normal">U</mml:mi></mml:mrow><mml:mo>::=&#x22A5;</mml:mo><mml:mrow><mml:mo stretchy="false">|</mml:mo></mml:mrow><mml:mrow><mml:mi mathvariant="normal">D</mml:mi></mml:mrow><mml:mo stretchy="false">&#x2192;</mml:mo><mml:mrow><mml:mi mathvariant="normal">D</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">|</mml:mo></mml:mrow><mml:mo fence="false" stretchy="false">{</mml:mo><mml:mi>a</mml:mi><mml:mo>:</mml:mo><mml:mrow><mml:mi mathvariant="normal">D</mml:mi></mml:mrow><mml:mo fence="false" stretchy="false">}</mml:mo><mml:mo>&#x2223;</mml:mo><mml:mrow><mml:mi mathvariant="normal">U</mml:mi></mml:mrow><mml:mo>&#x2294;</mml:mo><mml:mi mathvariant="normal">#</mml:mi><mml:mi>T</mml:mi></mml:mtd><mml:mtd><mml:mrow><mml:mi mathvariant="script">R</mml:mi></mml:mrow><mml:mo>::=</mml:mo><mml:mi mathvariant="normal">&#x22A4;</mml:mi><mml:mo>&#x2223;</mml:mo><mml:mo fence="false" stretchy="false">{</mml:mo><mml:mover><mml:mrow><mml:mi>a</mml:mi><mml:mo>:</mml:mo><mml:mrow><mml:mi mathvariant="normal">D</mml:mi></mml:mrow></mml:mrow><mml:mo accent="true">&#x2015;</mml:mo></mml:mover><mml:mo fence="false" stretchy="false">}</mml:mo></mml:mtd></mml:mtr></mml:mtable></mml:math></disp-formula>
<p>The function <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathsf{dnf}(\cdot)$]]></texMath></inlineMaths> converts arbitrary types to RDNFs. The task is essentially straightforward, if relatively tedious. Essentially, <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathsf{dnf}(\cdot)$]]></texMath></inlineMaths> pushes negations in using DeMorgan laws, distributes intersections over unions, and at the same time ensures that all constructed conjunctions are de-duplicated and as reduced as possible, so that for instance intersections of unrelated tags are reduced to <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\bot$]]></texMath></inlineMaths> and function and record types are merged with themselves. See our previous work [Parreaux and Chau 2022b] for the full definition of <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathsf{dnf}(\cdot)$]]></texMath></inlineMaths>, where it is denoted as <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathsf{dnf}^0(\cdot)$]]></texMath></inlineMaths>.
<statement id="lem-5_1">
<label>Lemma 5.1.</label>
<title>(Correctness of <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathsf{dnf}$]]></texMath></inlineMaths>).</title>
<p>For all <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau$]]></texMath></inlineMaths> and <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathsf{D = \mathsf{dnf}(\tau)$]]></texMath></inlineMaths>, we have <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau == \mathsf{D$]]></texMath></inlineMaths>.</p>
</statement>
<sec id="sec5_2">
<label>5.2</label>
<title>Completeness of Homomorphisms</title>
<statement id="lem-5_2">
<label>Lemma 5.2.</label>
<title>Completeness of characteristic homomorphisms</title>
<p>If <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\TTV\tau \cup \TTV\pi = \emptyset$]]></texMath></inlineMaths> and <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\lhd\Sigma |- [|\tau|] =< [|\pi|]$]]></texMath></inlineMaths> for all characteristic homomorphisms <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$[|\cdot|]$]]></texMath></inlineMaths>, then <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\rhd\Sigma |- \tau =< \pi$]]></texMath></inlineMaths>.</p>
</statement>
<p>P<sc>roof</sc>.  By the laws of Boolean algebras, the assumption <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\lhd\Sigma |- [|\tau|] =< [|\pi|]$]]></texMath></inlineMaths> implies:</p>
<disp-formula id="eqn"><label>(1)</label><mml:math display='block'><mml:mtable displaystyle="true"><mml:mlabeledtr><mml:mtd id="mjx-eqn:1"><mml:mtext>(1)</mml:mtext></mml:mtd><mml:mtd><mml:mo>&#x25C3;</mml:mo><mml:mi mathvariant="normal">&#x03A3;</mml:mi><mml:mo>&#x22A2;</mml:mo><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">[</mml:mo></mml:mrow><mml:mi>&#x03C4;</mml:mi><mml:mo>&#x2293;</mml:mo><mml:mi mathvariant="normal">&#x00AC;</mml:mi><mml:mi>&#x03C0;</mml:mi><mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mo>&#x2264;&#x22A5;</mml:mo></mml:mtd></mml:mlabeledtr></mml:mtable></mml:math></disp-formula>
<p>By Lemma 5.1 and the monotonicity of characteristic homomorphisms, (1) imply:
<disp-formula id="eqn"><label>(2)</label><mml:math display='block'><mml:mtable displaystyle="true"><mml:mlabeledtr><mml:mtd id="mjx-eqn:2"><mml:mtext>(2)</mml:mtext></mml:mtd><mml:mtd><mml:mo>&#x25C3;</mml:mo><mml:mi mathvariant="normal">&#x03A3;</mml:mi><mml:mo>&#x22A2;</mml:mo><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">[</mml:mo></mml:mrow><mml:mi>dnf</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>&#x03C4;</mml:mi><mml:mo>&#x2293;</mml:mo><mml:mi mathvariant="normal">&#x00AC;</mml:mi><mml:mi>&#x03C0;</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mo>&#x2264;&#x22A5;</mml:mo></mml:mtd></mml:mlabeledtr></mml:mtable></mml:math></disp-formula>
<p>Since <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\TTV\tau \cup \TTV\pi = \emptyset$]]></texMath></inlineMaths>, we have <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathsf{dnf}(\tau \sqcap \neg\pi) = \bigsqcup_i{(\mathsf{I_i \sqcap \neg\mathsf{U_i)}$]]></texMath></inlineMaths> for some <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\overline{\mathsf{I_i}^i$]]></texMath></inlineMaths> and <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\overline{\mathsf{U_i}^i$]]></texMath></inlineMaths>. Then (\ref{eqn:compl-homomorphisms-5}) becomes:</p>
<disp-formula id="eqn"><label>(3)</label><mml:math display='block'><mml:mtable displaystyle="true"><mml:mlabeledtr><mml:mtd id="mjx-eqn:3"><mml:mtext>(3)</mml:mtext></mml:mtd><mml:mtd><mml:mo>&#x25C3;</mml:mo><mml:mi mathvariant="normal">&#x03A3;</mml:mi><mml:mo>&#x22A2;</mml:mo><mml:munder><mml:mo>&#x2A06;</mml:mo><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:munder><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">[</mml:mo></mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="normal">I</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mo>&#x2293;</mml:mo><mml:mi mathvariant="normal">&#x00AC;</mml:mi><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">[</mml:mo></mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="normal">U</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>&#x2264;&#x22A5;</mml:mo></mml:mtd></mml:mlabeledtr></mml:mtable></mml:math></disp-formula>
<p>By the laws of Boolean algebras, (3) implies:</p>
<disp-formula id="eqn"><label>(4)</label><mml:math display='block'><mml:mtable displaystyle="true"><mml:mlabeledtr><mml:mtd id="mjx-eqn:4"><mml:mtext>(4)</mml:mtext></mml:mtd><mml:mtd><mml:msup><mml:mrow><mml:mover><mml:mrow><mml:mo>&#x25C3;</mml:mo><mml:mi mathvariant="normal">&#x03A3;</mml:mi><mml:mo>&#x22A2;</mml:mo></mml:mrow><mml:mo accent="true">&#x2015;</mml:mo></mml:mover><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">[</mml:mo></mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="normal">I</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mo>&#x2264;</mml:mo><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">[</mml:mo></mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="normal">U</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mo fence="true" stretchy="true" symmetric="true"></mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msup></mml:mtd></mml:mlabeledtr></mml:mtable></mml:math></disp-formula></p>
<p>By Lemma 5.3, (4) implies:
<disp-formula id="eqn"><label>(5)</label><mml:math display='block'><mml:mtable displaystyle="true"><mml:mlabeledtr><mml:mtd id="mjx-eqn:5"><mml:mtext>(5)</mml:mtext></mml:mtd><mml:mtd><mml:msubsup><mml:mrow><mml:mover><mml:mrow><mml:mi mathvariant="normal">&#x0394;</mml:mi><mml:mo>&#x2211;</mml:mo><mml:mo>&#x22A2;</mml:mo><mml:msub><mml:mi>I</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>&#x2264;</mml:mo><mml:msub><mml:mi>U</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo accent="true">&#x2015;</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msubsup></mml:mtd></mml:mlabeledtr></mml:mtable></mml:math></disp-formula>
<p>By swapping and S-A<sc>nd</sc>O<sc>r</sc>2}+, (\ref{eqn:compl-homomorphisms-8}) implies:</p>
<disp-formula id="eqn"><label>(6)</label><mml:math display='block'><mml:mtable displaystyle="true"><mml:mlabeledtr><mml:mtd id="mjx-eqn:5"><mml:mtext>(5)</mml:mtext></mml:mtd><mml:mtd><mml:msubsup><mml:mrow><mml:mover><mml:mrow><mml:mi mathvariant="normal">&#x0394;</mml:mi><mml:mo>&#x2211;</mml:mo><mml:mo>&#x22A2;</mml:mo><mml:msub><mml:mi>I</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>&#x2264;</mml:mo><mml:msub><mml:mi>U</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo accent="true">&#x2015;</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msubsup></mml:mtd></mml:mlabeledtr></mml:mtable></mml:math></disp-formula>
<p>By Lemma 5.1 and swapping\ifdefined\ExcludeApps\else(Theorem~\ref{thm:swapping}+)\fi, (\ref{eqn:compl-homomorphisms-10}) implies:</p>
<disp-formula id="eqn"><label>(7)</label><mml:math display='block'><mml:mtable displaystyle="true"><mml:mlabeledtr><mml:mtd id="mjx-eqn:7"><mml:mtext>(7)</mml:mtext></mml:mtd><mml:mtd><mml:mo>&#x25B9;</mml:mo><mml:mi mathvariant="normal">&#x03A3;</mml:mi><mml:mo>&#x22A2;</mml:mo><mml:mi>&#x03C4;</mml:mi><mml:mo>&#x2264;</mml:mo><mml:mi>&#x03C0;</mml:mi></mml:mtd></mml:mlabeledtr></mml:mtable></mml:math></disp-formula>
</statement>
<statement id="lem-5_3">
<label>Lemma 5.3.</label>
<title>Completeness of characteristic homomorphisms on reduced intersections and unions</title>
<p>If <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\lhd\Sigma |- [|\mathsf{I|] =< [|\mathsf{U|]$]]></texMath></inlineMaths> for all characteristic homomorphisms <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$[|\cdot|]$]]></texMath></inlineMaths>, then <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\rhd\Sigma |- \mathsf{I =< \mathsf{U$]]></texMath></inlineMaths>.</p>
</statement>
<p>P<sc>roof</sc>.   We prove the contrapositive: if <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\rhd\Sigma |- \mathsf{I \nleq \mathsf{U$]]></texMath></inlineMaths>, then <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\lhd\Sigma |- [|\mathsf{I|] \nleq [|\mathsf{U|]$]]></texMath></inlineMaths> for some homomorphism <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$[|\cdot|]$]]></texMath></inlineMaths>. Let <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathsf{U = \mathsf{U_0 \sqcup \bigsqcup_i{{\#}{S_i}}$]]></texMath></inlineMaths>, where <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathsf{U_0$]]></texMath></inlineMaths> is not a union. By case analysis on  <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathsf{I$]]></texMath></inlineMaths> and <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathsf{U_0$]]></texMath></inlineMaths>.</p>
<list-item><p><b>Cases <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathsf{I = \rcd{\overline{a: \tau_a}^a}$]]></texMath></inlineMaths> and <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathsf{I = \tau_1 &#x2192; \tau_2 \sqcap \rcd{\overline{a: \tau_a}^a}$]]></texMath></inlineMaths>. See Proof~\ref{prf:compl-homomorphisms-red}.</p></list-item>
<list-item><p><b>Case</b> <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathsf{I = \textit{T} \sqcap (\tau_1 &#x2192; \tau_2)^? \sqcap \rcd{\overline{a: \tau_a}^a}$]]></texMath></inlineMaths>. \strut</p></list-item>
<list-item><p><b>Case</b> <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T \preceq S_k$]]></texMath></inlineMaths> for some <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$k$]]></texMath></inlineMaths>. By S-T<sc>ag</sc>S<sc>ub</sc>}, <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T \preceq S_k$]]></texMath></inlineMaths> implies <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\textit{T} =< {\#}{S_k}$]]></texMath></inlineMaths>, which by S-T<sc>rans</sc> with S-A<sc>nd</sc>O<sc>r</sc>11}<inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\pm$]]></texMath></inlineMaths>/S-A<sc>nd</sc>O<sc>r</sc>12}<inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\pm$]]></texMath></inlineMaths> implies <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathsf{I =< \mathsf{U$]]></texMath></inlineMaths>, which leads to a contradiction. Therefore this case is impossible.</p></list-item>
<list-item><p><b>Case</b> <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\overline{T \not\preceq S_i}^i$]]></texMath></inlineMaths>. \strut</p></list-item>
<list-item><p><b>Case</b> <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathsf{U_0 = \bot$]]></texMath></inlineMaths>. Then <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{I{[|\mathsf{I|]} = \subclasses\DCtxScript{T} \times (\mathcal{F \setminus \setLitTight{\overline{a}})$]]></texMath></inlineMaths> but <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{I{[|\mathsf{U|]} = \bigcup_i{\subclasses\DCtxScript{{S_i}}} \times \mathcal{F$]]></texMath></inlineMaths>. Since <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$(T, c) \in \mathcal{I{[|\mathsf{I|]}$]]></texMath></inlineMaths> for all <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$c \notin \setLitTight{\overline{a}}$]]></texMath></inlineMaths> but <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$(T, c) \notin \mathcal{I{[|\mathsf{U|]}$]]></texMath></inlineMaths>, we have <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{I{[|\mathsf{I|]} \nleq \mathcal{I{[|\mathsf{U|]}$]]></texMath></inlineMaths>.</p></list-item>
<list-item><p><b>Case</b> <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathsf{U_0 = \pi_1 &#x2192; \pi_2$]]></texMath></inlineMaths>. \strut</p></list-item>
<list-item><p><b>Case</b> <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$(\tau_1 &#x2192; \tau_2) \in \mathsf{I$]]></texMath></inlineMaths>. \strut</p></list-item>
<list-item><p><b>Case</b> <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\lhd\Sigma |- \pi_1 \nleq \tau_1$]]></texMath></inlineMaths>. Then <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{D{[|\mathsf{I|]}^{&#x2192;}_T = \neg\tau_1$]]></texMath></inlineMaths> and <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{D{[|\mathsf{U|]}^{&#x2192;}_T = \neg\pi_1$]]></texMath></inlineMaths>. By the contrapositive of S-N<sc>eg</sc>I<sc>nv</sc>} and double negation introduction/elimination, the assumption of this case implies <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\lhd\Sigma |- \neg\tau_1 \nleq \neg\pi_1$]]></texMath></inlineMaths>, i.e., <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\lhd\Sigma |- \mathcal{D{[|\mathsf{I|]}^{&#x2192;}_T \nleq \mathcal{D{[|\mathsf{U|]}^{&#x2192;}_T$]]></texMath></inlineMaths>.</p></list-item>
<list-item><p><b>Case</b> <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\lhd\Sigma |- \tau_2 \nleq \pi_2$]]></texMath></inlineMaths>. Then <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{C{[|\mathsf{I|]}_{&#x2192;}^T = \tau_2$]]></texMath></inlineMaths> and <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{C{[|\mathsf{U|]}_{&#x2192;}^T = \pi_2$]]></texMath></inlineMaths>. Then from the assumption of this case, we have <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\lhd\Sigma |- \mathcal{C{[|\mathsf{I|]}_{&#x2192;}^T \nleq \mathcal{C{[|\mathsf{U|]}_{&#x2192;}^T$]]></texMath></inlineMaths>.</p></list-item>
<list-item><p><b>Case</b> <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\lhd\Sigma |- \pi_1 =< \tau_1 \wedge \lhd\Sigma |- \tau_2 =< \pi_2$]]></texMath></inlineMaths>. By S-F<sc>un</sc>D<sc>epth</sc>}, <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\lhd\Sigma |- \pi_1 =< \tau_1$]]></texMath></inlineMaths> and <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\lhd\Sigma |- \tau_2 =< \pi_2$]]></texMath></inlineMaths> imply <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\rhd\Sigma |- \tau_1 &#x2192; \tau_2 =< \pi_1 &#x2192; \pi_2$]]></texMath></inlineMaths>, which by S-T<sc>rans</sc> with S-A<sc>nd</sc>O<sc>r</sc>11}<inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\pm$]]></texMath></inlineMaths>/S-A<sc>nd</sc>O<sc>r</sc>12}<inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\pm$]]></texMath></inlineMaths> implies <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\rhd\Sigma |- \mathsf{I =< \mathsf{U$]]></texMath></inlineMaths>, which leads to a contradiction. Therefore this case is impossible.</p></list-item>
<list-item><p><b>Case</b> <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$(\tau_1 &#x2192; \tau_2) \notin \mathsf{I$]]></texMath></inlineMaths>. Then <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{H{[|\mathsf{I|]} = \subclasses\DCtxScript{T}$]]></texMath></inlineMaths> but <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{H{[|\mathsf{U|]} = \setLitTight{{&#x2192;}} \cup \bigcup_i{\subclasses\DCtxScript{{S_i}}}$]]></texMath></inlineMaths>. Since <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T \in \mathcal{H{[|\mathsf{I|]}$]]></texMath></inlineMaths> but <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T \notin \mathcal{H{[|\mathsf{U|]}$]]></texMath></inlineMaths>, we have <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{H{[|\mathsf{I|]} \nleq \mathcal{H{[|\mathsf{U|]}$]]></texMath></inlineMaths>. </p></list-item>
<list-item><p><b>Case</b> <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathsf{U_0 = \{\,b: \pi\,\}$]]></texMath></inlineMaths>. \strut</p></list-item>
<list-item><p><b>Case</b> <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$b \notin \setLitTight{\overline{a}}$]]></texMath></inlineMaths>. Then <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{I{[|\mathsf{I|]} = \subclasses\DCtxScript{T} \times (\mathcal{F \setminus \setLitTight{\overline{a}})$]]></texMath></inlineMaths> but <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{I{[|\mathsf{U|]} = (\mathbf{U} \times (\mathcal{F \setminus \br{\hspace{.1em}{b}\hspace{.1em}})) \cup (\bigcup_i{\subclasses\DCtxScript{{S_i}}} \times \mathcal{F)$]]></texMath></inlineMaths>. Since <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$(T, b) \in \mathcal{I{[|\mathsf{I|]}$]]></texMath></inlineMaths> but <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$(T, b) \notin \mathcal{I{[|\mathsf{U|]}$]]></texMath></inlineMaths>, we have <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{I{[|\mathsf{I|]} \nleq \mathcal{I{[|\mathsf{U|]}$]]></texMath></inlineMaths>.</p></list-item>
<list-item><p><b>Case</b> <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$b \in \setLitTight{\overline{a}}$]]></texMath></inlineMaths>. \strut</p></list-item>
<list-item><p><b>Case</b> <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\lhd\Sigma |- \tau_b \nleq \pi$]]></texMath></inlineMaths>. Then <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{J{[|\mathsf{I|]}_b^T = \tau_b$]]></texMath></inlineMaths> and <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{J{[|\mathsf{U|]}_b^T = \pi$]]></texMath></inlineMaths>. Then from the assumption of this case, we have <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\lhd\Sigma |- \mathcal{J{[|\mathsf{I|]}_b^T \nleq \mathcal{J{[|\mathsf{U|]}_b^T$]]></texMath></inlineMaths>.</p></list-item>
<list-item><p><b>Case</b> <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\lhd\Sigma |- \tau_b =< \pi$]]></texMath></inlineMaths>. By S-R<sc>cd</sc>D<sc>epth</sc>}, <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\lhd\Sigma |- \tau_b =< \pi$]]></texMath></inlineMaths> implies <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\rhd\Sigma |- \{\,b: \tau_b\,\} =< \{\,b: \pi\,\}$]]></texMath></inlineMaths>, which by S-T<sc>rans</sc> with S-A<sc>nd</sc>O<sc>r</sc>11}<inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\pm$]]></texMath></inlineMaths>/S-A<sc>nd</sc>O<sc>r</sc>12}<inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\pm$]]></texMath></inlineMaths> implies <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\rhd\Sigma |- \mathsf{I =< \mathsf{U$]]></texMath></inlineMaths>, which leads to a contradiction. Therefore this case is impossible.</p></list-item>
</list>
</statement>
</sec>
<sec id="sec">
<label>5.3</label>
<title>Hardness of Subtyping</title>
<p>We now discuss the hardness of subtyping. We only consider subtype checking between two closed types, i.e., types without flexible type variables, except for those equi-bounded type variables that stand for desugared recursive types (as described in Section 2.2.5). Interestingly, though, recursive types are not needed for the proof to go through. The proof relies on unions of function types, which will not often arise in practice; nevertheless, when doing type inference, one can get into similar problems with a conjunction of type annotations and fresh flexible type variables.</p>
<sec id="sec5_3_1">
<label>5.3.1</label>
<title>A New Subtyping Algorithm</title>
<p>The statement of Lemma 5.2 suggests a new subtype checking algorithm: checking subtyping between two types is equivalent to checking whether the order of their images is preserved under each characteristic homomorphism. This algorithm is described in Appendix~\ref{sec:algorithm}. However, just like the existing algorithm, this new algorithm is still exponential in the worst case. Next, we show that the problem is in fact co-NP-hard, suggesting that no polynomial-time algorithm exists unless <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathbf{P} = \mathbf{NP}$]]></texMath></inlineMaths> [Arora and Barak 2009].</p>
</sec>
<sec id="sec5_3_2">
<label>5.3.2</label>
<title>Co-NP-Hardness</title>
<p>\textbf{co-NP} is the complement class of the complexity class \textbf{NP}. If a decision problem is in \textbf{NP}, then its complement problem, obtained by reversing the answers, is in \textbf{co-NP}. A problem is co-NP-hard if every problem in \textbf{co-NP} can be reduced to it in polynomial time.</p>
</sec>
<sec id="sec5_3_3">
<label>5.3.3</label>
<title>Co-NP-Hardness of Subtyping Decision</title>
<p>We show the co-NP-hardness of deciding subtyping in MLstruct<sup>+</sup> by a reduction from the tautology problem, i.e., the complement of the Boolean satisfiability problem: the problem of determining if a Boolean formula is true in all possible assignments of the variables. The proof proceeds by first defining an encoding of propositional logic formulas and the satisfiability problem into respectively types and subtyping problems using Boolean homomorphisms and then showing that the homomorphisms are monotonic, i.e., that our encoding is sound. Interestingly, the proof applies to any type system with reasonably-behaved unions and intersections, base types, and function types, even without recursive types and even when unions and intersections do not distribute over functions and records.</p>
<p>When we say &#x201C;Boolean algebra of propositional logic formulas&#x201D;, we refer to the Boolean algebra consisting of the closure of the distinct elements <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\setLit{\top ** \bot ** \overline{x_i}^i}$]]></texMath></inlineMaths> under the three Boolean connectives (<inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\wedge$]]></texMath></inlineMaths>, <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\vee$]]></texMath></inlineMaths>, <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\neg$]]></texMath></inlineMaths>), ordered by the minimal relation satisfying the axioms of Boolean algebra.
<statement id="def-5_4">
<label>Definition 5.4.</label>
<title>Encoding of propositional logic formulas as types</title>
<p>The Boolean homomorphism <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{P{[|\cdot|]}$]]></texMath></inlineMaths> from the Boolean algebra of propositional logic formulas to the Boolean algebra of types ordered by subtyping under the empty context is defined as:</p>
<disp-formula id="eqn"><label></label><mml:math display='block'><mml:mrow><mml:mi mathvariant="script">P</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">[</mml:mo></mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mtable columnalign="left left" columnspacing="1em" rowspacing=".2em"><mml:mtr><mml:mtd><mml:mi mathvariant="normal">#</mml:mi><mml:mrow><mml:mi>Obj</mml:mi></mml:mrow></mml:mtd><mml:mtd><mml:mtext>&#x00A0;if&#x00A0;</mml:mtext><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mtext>&#x00A0;</mml:mtext><mml:mi mathvariant="normal">T</mml:mi></mml:mrow><mml:mo stretchy="false">&#x2192;</mml:mo><mml:mrow><mml:mi mathvariant="script">P</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">[</mml:mo></mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:mi>i</mml:mi><mml:mo>&#x2212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd><mml:mtd><mml:mtext>&#x00A0;if&#x00A0;</mml:mtext><mml:mi>i</mml:mi><mml:mo>&gt;</mml:mo><mml:mn>0</mml:mn></mml:mtd></mml:mtr></mml:mtable><mml:mo fence="true" stretchy="true" symmetric="true"></mml:mo></mml:mrow></mml:math></disp-formula>
</statement>
<statement id="lem-5_5">
<label>Lemma 5.5.</label>
<p><inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{P{[|\cdot|]}$]]></texMath></inlineMaths> is monotonic.</p>
<p>P<sc>roof</sc>.   Immediate since the Boolean algebra of propositional logic formulas is ordered by the minimal relation satisfying the axioms of Boolean algebra and the pure Boolean-algebraic subtyping rules are a proper axiomatization of Boolean algebra [Parreaux and Chau 2022b, ยงB.8].</p>
</statement>
<statement id="def-5_6">
<label>Definition 5.6.</label>
<p>The logic formula endomorphism <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{S{[|\cdot|]}$]]></texMath></inlineMaths> is defined as:</p>
<p><inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{S{[|x_i|]} = x_{i+1}$]]></texMath></inlineMaths>.</p>
</statement>
<statement id="lem-5_7">
<label>Lemma 5.7.</label>
<p><inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{S{[|\cdot|]}$]]></texMath></inlineMaths> is monotonic.</p>
</statement>
<p>P<sc>roof</sc>.   Trivial as variables are treated symmetrically in the Boolean algebra of propositional logic formulas and <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{S{[|\cdot|]}$]]></texMath></inlineMaths> is an injective renaming of variables.
</statement>
<statement id="def-5_8">
<label>Definition 5.8.</label>
<title>(Projection of types as propositional logic formulas)</title>
<p>The Boolean homomorphism <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{Q{[|\cdot|]}$]]></texMath></inlineMaths> from the Boolean algebra of types ordered by subtyping under the empty context to the Boolean algebra of propositional logic formulas is defined as:</p>
<disp-formula id="eqn"><label></label><mml:math display='block'><mml:mi>Q</mml:mi><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">[</mml:mo></mml:mrow><mml:msub><mml:mi>&#x03C4;</mml:mi><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo stretchy="false">&#x2192;</mml:mo><mml:msub><mml:mi>&#x03C4;</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mi mathvariant="script">S</mml:mi></mml:mrow><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">[</mml:mo></mml:mrow><mml:mi>Q</mml:mi><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">[</mml:mo></mml:mrow><mml:msub><mml:mi>&#x03C4;</mml:mi><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mstyle scriptlevel="0"><mml:mspace width="1em"></mml:mspace></mml:mstyle><mml:mi>Q</mml:mi><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">[</mml:mo></mml:mrow><mml:mo fence="false" stretchy="false">{</mml:mo><mml:mi>a</mml:mi><mml:mo>:</mml:mo><mml:mi>&#x03C4;</mml:mi><mml:mo fence="false" stretchy="false">}</mml:mo><mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi mathvariant="normal">&#x22A4;</mml:mi><mml:mstyle scriptlevel="0"><mml:mspace width="1em"></mml:mspace></mml:mstyle><mml:mi>Q</mml:mi><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">[</mml:mo></mml:mrow><mml:mi mathvariant="normal">#</mml:mi><mml:mi>T</mml:mi><mml:mrow><mml:mo stretchy="false">]</mml:mo><mml:mstyle scriptlevel="0"><mml:mspace width="-0.167em"></mml:mspace></mml:mstyle><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mtable columnalign="left left" columnspacing="1em" rowspacing=".2em"><mml:mtr><mml:mtd><mml:msub><mml:mi>x</mml:mi><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd><mml:mtext>&#x00A0;if&#x00A0;</mml:mtext><mml:mi>T</mml:mi><mml:mo>=</mml:mo><mml:mtext>&#x00A0;Obj&#x00A0;</mml:mtext></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mo>&#x22A5;</mml:mo></mml:mtd><mml:mtd><mml:mtext>&#x00A0;otherwise&#x00A0;</mml:mtext></mml:mtd></mml:mtr></mml:mtable><mml:mo fence="true" stretchy="true" symmetric="true"></mml:mo></mml:mrow></mml:math></disp-formula>
<statement id="lem-5_9">
<label>Lemma 5.9.</label>
<p><inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{Q{[|\cdot|]}$]]></texMath></inlineMaths> is monotonic.</p>
</statement>
<p>P<sc>roof</sc>.   We show by induction on unassuming subtyping derivations that the subtyping relation is compatible with <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{Q{[|\cdot|]}$]]></texMath></inlineMaths>. The only non-trivial cases are S-T<sc>ag</sc>S<sc>ub</sc>}, S-T<sc>ag</sc>B<sc>ot</sc>}, and S-F<sc>un</sc>D<sc>epth</sc>}.</p>
<list>
<list-item><p><b>Case S-T<sc>ag</sc>S<sc>ub</sc>.}</b> The rule has premise <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T_1 \preceq T_2$]]></texMath></inlineMaths> and conclusion <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[${\#}{T_1} =< {\#}{T_2}$]]></texMath></inlineMaths>.</p></list-item>
<list-item><p><b>Case</b> <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T_1 = \mtext{Obj}$]]></texMath></inlineMaths>. Then the premise of the rule is <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mtext{Obj} \preceq T_2$]]></texMath></inlineMaths>. Since all tags inherit from Obj, we also have <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T_2 \preceq \mtext{Obj}$]]></texMath></inlineMaths>. By acyclicity of inheritance, we have <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T_2 = \mtext{Obj}$]]></texMath></inlineMaths>. Then the conclusion maps to <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$x_0 =< x_0$]]></texMath></inlineMaths>.</p></list-item>
<list-item><p><b>Case</b> <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T_1 \neq \mtext{Obj}$]]></texMath></inlineMaths>. Then the conclusion maps to <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\bot =< \mathcal{Q{[|{\#}{T_2}|]}$]]></texMath></inlineMaths>.</p></list-item>
</list>
<list-item><p><b>Case S-T<sc>ag</sc>B<sc>ot</sc>}.</b> The rule has premises <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T_2 \not\preceq T_1$]]></texMath></inlineMaths> and <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T_1 \not\preceq T_2$]]></texMath></inlineMaths>, i.e., <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T_1$]]></texMath></inlineMaths> and <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T_2$]]></texMath></inlineMaths> are unrelated, and conclusion <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[${\#}{T_1} \sqcap {\#}{T_2} =< \bot$]]></texMath></inlineMaths>. By reflexivity of inheritance, either <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T_1 \neq \mtext{Obj}$]]></texMath></inlineMaths> or <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$T_2 \neq \mtext{Obj}$]]></texMath></inlineMaths>. Then the conclusion maps to <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\bot \wedge \mathcal{Q{[|{\#}{T_2}|]} =< \bot$]]></texMath></inlineMaths> or <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{Q{[|{\#}{T_1}|]} \wedge \bot =< \bot$]]></texMath></inlineMaths> respectively.</p></list-item>
<list-item><p><b>Case S-F<sc>un</sc>D<sc>epth</sc>}.</b>       The rule has premises <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau_0 =< \tau_1$]]></texMath></inlineMaths> and <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau_2 =< \tau_3$]]></texMath></inlineMaths> and conclusion <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau_1 &#x2192; \tau_2 =< \tau_0 &#x2192; \tau_3$]]></texMath></inlineMaths> for some <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau_0$]]></texMath></inlineMaths>, <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau_1$]]></texMath></inlineMaths>, <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau_2$]]></texMath></inlineMaths>, and <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\tau_3$]]></texMath></inlineMaths>. By IH on the second premise, we have <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{Q{[|\tau_2|]} =< \mathcal{Q{[|\tau_3|]}$]]></texMath></inlineMaths>. Then by the monotonicity of <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{S{[|\cdot|]}$]]></texMath></inlineMaths>, we have <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{S{[| \mathcal{Q{[|\tau_2|]}|]} =< \mathcal{S{[| \mathcal{Q{[|\tau_3|]}|]}$]]></texMath></inlineMaths> which is what the conclusion maps to.</p></list-item>
</list>
</statement>
<statement id="lem-5_10">
<label>Lemma 5.10.</label>
<p><inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{Q{[|\mathcal{P{[|p|]}|]} = p$]]></texMath></inlineMaths> for all <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$p$]]></texMath></inlineMaths>.</p>
</statement>
<p>P<sc>roof</sc>.   Trivial.</p>
<statement id="lem-5_11">
<label>Lemma 5.11.</label>
<title>Reduction of Boolean satisfiability to subtyping</title>
<p>A propositional logic formula <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$p$]]></texMath></inlineMaths> is tautological (i.e., <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\top =< p$]]></texMath></inlineMaths>) if and only if <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\top$]]></texMath></inlineMaths> is a subtype of <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{P{[|p|]}$]]></texMath></inlineMaths> (i.e., <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\top =< \mathcal{P{[|p|]}$]]></texMath></inlineMaths>).</p>
</statement>
<p>P<sc>roof</sc>.   First, we justify our assertion that <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$p$]]></texMath></inlineMaths> is tautological if and only if <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\top =< p$]]></texMath></inlineMaths>:   this is due to the completeness of Boolean algebra. The Boolean algebra of propositional logic formulas is essentially the restriction to the zeroth order of the system LK of sequent calculus [Gentzen 1935a], which has been shown to be equivalent to other formalizations of classical predicate logic [Gentzen 1935b]. The fact that a formula <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$p$]]></texMath></inlineMaths> is a tautology is expressed by the sequent <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$&#x2192; p$]]></texMath></inlineMaths>, which corresponds to <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\top =< p$]]></texMath></inlineMaths> in our notation.
<p>The forward direction follows from the monotonicity of <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{P{[|\cdot|]}$]]></texMath></inlineMaths>. The backward direction follows from the monotonicity of <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathcal{Q{[|\cdot|]}$]]></texMath></inlineMaths> and Lemma~\ref{lem:invsathom}.</p>
</statement>
</sec>
<sec id="sec6">
<label>6</label>
<title>Related Work</title>
<p>We now briefly review some related work.</p>
<p><italic>Intersection type systems</italic>. Intersection types for lambda calculus were pioneered by  Coppo and
Dezani-Ciancaglini [1980]; Barendregt et al. [1983], after whom the &#x201C;BCD&#x201D; type system is named. BCD is very powerful and coincides with strong normalization [Ghilezan 1996], making type inference undecidable. By contrast, MLstruct<sup>+</sup> does not need the powerful intersection introduction rule, retaining decidability of type inference. It is worth noting that most other modern type system with intersection types, including those of the mainstream programming languages mentioned before, do not have that rule either. Some systems use intersection types to encode a form of overloading [Pierce 1991], but this is not possible to support as is in a Boolean-algebraic subtyping system. Pottier [1998] uses a <italic>greatest lower bound</italic> connective <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\sqcap$]]></texMath></inlineMaths> that resembles our type intersection
<p><italic>Union and intersection types in programming</italic>. Union types were introduced by MacQueen et al.
[1986], and are present in many modern languages, often along intersection types. These types have seen a recent resurgence, gaining a lot of traction both in academia [Alpuim et al. 2017; Binder et al.
2022; Castagna et al. 2022; Dunfield 2012; Huang and Oliveira 2021; Muehlboeck and Tate 2018;
Rehman et al. 2022] and in industry,<xref ref-type="fn" id="fn10"><sup>10</sup></xref> with several industry-grade programming languages like TypeScript, Flow, and Scala 3 supporting them, in addition to a myriad of lesser-known research languages.
<p><italic>Type inference for unions and intersections</italic>. Aiken and Wimmers [1993]; Aiken et al. [1994] impose very strict restrictions on negative unions (they must be disjoint) and on positive intersections (they must not have free variables and must be &#x201C;upward closed&#x201D;). Trifonov and Smith [1996] go further and restrict intersections to <italic>negative</italic> or <italic>input</italic> positions (those appearing on the right of <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$=<$]]></texMath></inlineMaths> constraints) and unions types to <italic>positive</italic> or <italic>output</italic> positions (those appearing on the left). Binder
et al. [2022]; Dolan [2017]; Parreaux [2020]; Pottier [1998] all follow the same idea. In these systems, unions and intersections are not <italic>first-class</italic> citizens: they cannot be used freely in type annotations. Frisch et al. [2008] infer set-theoretic types (see \textit{semantic subtyping} below) for a higher-order language with overloading but do not infer polymorphic types. Castagna et al. [2016] propose a complete polymorphic set-theoretic type inference system, but their types are not principal so their algorithm returns several solutions, which leads to the need for backtracking.
<p><italic>Recursive types</italic>. {Equirecursive} types, where a recursive type is <italic>equivalent</italic> to its unfolding, have a long history in programming languages research [Abadi and Fiore 1996; Amadio and Cardelli 1993;
Appel et al. 2007; Hosoya et al. 2005; MacQueen et al. 1986; Pierce 2002], dating as far back as Morris&#x2019; thesis, where he conjectured their use under the name of <italic>cyclic types</italic> [Morris 1969, pp.122โ124]. Recursive types with subtyping were developed in the foundational work of Amadio and Cardelli [1993] and Brandt and Henglein [1998] gave a coinductive axiomatization of such recursive types. Jim and Palsberg [1999] described a co-inductive formalization of recursive types as arbitrary infinite trees which is more general than approaches like ours, which only allows reasoning about <italic>regular</italic> types. Nevertheless, the algorithms they gave were unsurprisingly restricted to regular types. Gapeyev et al. [2002]; Pierce [2002] reconciled the representation as infinite regular trees with the representation as <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mu$]]></texMath></inlineMaths> types, and described the standard algorithms to decide the corresponding subtyping relationship. An important aspect of practical recursive type algorithms is that one needs to maintain the cache of discovered subtyping relationships <italic>across recursive calls</italic> to avoid exponential blowup [Gapeyev et al. 2002]. Our implementation of MLstruct<sup>+</sup> follows the same principle, as a naive implementation of MLstruct<sup>+</sup> would lead to exactly the same blowup. Also refer to Section 2.5.2 for more parallels between the handling of recursive types in MLstruct<sup>+</sup> and previous work.</p>
<p><italic>Algebraic and Boolean-algebraic subtyping</italic>. Approaches like that of Pottier [1998] used a lattice-theoretic construction of types inspired by the connection between types and term automata. Meet <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\sqcap$]]></texMath></inlineMaths> and join <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\sqcup$]]></texMath></inlineMaths> operators resembling intersection and union types are used to compactly representing conjunctions of constraints, but these are not <italic>first-class</italic> types, in that they are restricted to appearing respectively in negative and positive positions only. MLstruct originally built on Simple-sub [Parreaux 2020], a reformulation of MLsub, from the original <italic>algebraic subtyping</italic> approach of Dolan [2017]; Dolan and Mycroft [2017]. [Bhanuka et al. 2023] showed how to report good errors from such type inference approaches. [Parreaux et al. 2024] use a similar type inference approach in the context of first-class polymorphism. Bachurski et al. [2025] use a subtyping system inspired by MLstruct and propose some future extensions to it, including homomorphic computations on types, which we have been independently considering.
<p><italic>Set- and Boolean-theoretic types</italic>. The <italic>semantic subtyping</italic> approaches [Castagna et al. 2022, 2016;
Frisch et al. 2002, 2008; Petrucciani 2019] view types as sets of values which inhabit them and define the subtyping relationship as set inclusion, giving set-based meaning to <italic>union</italic>, <italic>intersection</italic>, and <italic>negation</italic> (or <italic>complement</italic>) connectives. This is by contrast to algebraic subtyping, which may admit subtyping rules that <italic>violate</italic> the set-theoretic interpretation, such as function distributivity, to ensure that the subtyping lattice has desirable algebraic properties. For more detailed discussions contrasting semantic subtyping with other approaches, we refer the reader to the works of Parreaux
[2020] and Muehlboeck and Tate [2018]. Some authors turn to Boolean-algebraic type theories but without subtyping, such as Madsen and van de Pol [2020, 2021]. Boolean-algebraic type systems have also proven useful in the context of effect systems [Lutze et al. 2023], where subtyping was additionally used to avoid the problem of <italic>poisoning</italic> [Gao and Parreaux 2025].</p>

<p><italic>Polymorphic records/variants and row polymorphism</italic>. Polymorphic <italic>records</italic> are structurally-typed product types whose types admit the usual width and depth subtyping relationships. Their dual, polymorphic <italic>variants</italic> [Garrigue 1998, 2001], are another useful language feature, used to encode structural sum types. In their simplest expression, polymorphic records (resp. variants) do not support ad-hoc field extension (resp. default match cases). Previous approaches have thus extended polymorphic records and variants with <italic>row polymorphism</italic>, which uses a new kind of variables, named &#x201C;row&#x201D; variables, to record the presence and absence of fields (resp. cases) in a given type. Some approaches, like OCaml&#x2019;s polymorphic variants and object types, use row polymorphism exclusively to <italic>simulate</italic> subtype polymorphism, in order to avoid subtyping in the wider languages. However, in such systems, row polymorphism and subtyping actually complement each other well [Pottier 1998, Chapter 14.7]. There are also techniques for supporting variant and record extensibility through union, intersection, and negation types, as shown by Castagna et al. [2016];
Castagna and Peyrot [2025], who also explain that their system resolves long-standing limitations with OCaml-style row polymorphism, and through other mechanisms [Madsen et al. 2023]. In our system, we solve many (though not all) of these limitations, but we also support principal type inference. It is worth pointing out that OCaml&#x2019;s polymorphic variants [Garrigue 2001] and related systems based on kinds [Ohori 1995] lack support for <italic>polymorphic extension</italic> [Gaster and Jones 1996;
White 2015], whereas MLstruct<sup>+</sup> does not (see <monospace>mapSome</monospace> in the introduction). As a simpler example, <monospace>def foo x dflt els = case x of { Apple &#x2192; dflt || _ &#x2192; els x }</monospace> would be assigned a too restrictive type in OCaml and as a consequence <monospace>foo (Banana{}) 0 (fun z &#x2192; case z of  { Banana &#x2192; 1 })</monospace> would not type check (OCaml would complain that the function argument does not handle <monospace>Apple</monospace>). A more expressive row-polymorphic system exposing row variables to users would support this use case [Gaster and Jones 1996; Rรฉmy 1994], but even these are limited compared to MLstruct<sup>+</sup>.</p>
</sec>
<sec id="sec7">
<title>Conclusion and Future Work</title>
<p>In this paper, we presented MLstruct<sup>+</sup>, a variant of MLstruct that supports record extension without modifying the subtyping structure. We showed that the core ingredient of MLstruct and MLstruct<sup>+</sup>, namely Boolean-algebraic subtyping, can be condensed down to its in terms of five characteristic Boolean homomorphisms, which helped us prove the soundness of subtyping semantically in a faction of the space previously required, while suggesting a new decision procedure for subtyping, although we also showed that the problem is co-NP-hard, so there is little hope of achieving non-exponential worst-case time complexity.</p>
<p>In the future, we would like to take these insights further and explore how they could help us simplify the specification and proofs of the algorithmic aspects of MLstruct.
</sec>
</body>
<back>
<ack id="ack1">
<title>Acknowledgments</title>
<p>We would like to thank the anonymous reviewers for their invaluable comments and suggestions to improve the paper, as well as Chun Kit Lam, Yijia Chen, and Ross Tate for their feedback, help, and useful discussions.</p>
</ack>
<ref-list id="reflist1">
<title>References</title>
<ref id="ref001"><label>[1]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Martin</given-names> <surname>Abadi</surname></string-name> and <string-name><given-names>Marcelo P.</given-names> <surname>Fiore</surname></string-name></person-group>. <year>1996</year>. <article-title>Syntactic considerations on recursive types</article-title>. In <source><italic>Proceedings 11th Annual IEEE Symposium on Logic in Computer Science</italic></source>. <publisher-name>IEEE</publisher-name>, <fpage>242</fpage>&#x2013;<lpage>252</lpage>.</mixed-citation></ref>
<ref id="ref002"><label>[2]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Alexander</given-names> <surname>Aiken</surname></string-name> and <string-name><given-names>Edward L.</given-names> <surname>Wimmers</surname></string-name></person-group>. <year>1993</year>. <article-title>Type Inclusion Constraints and Type Inference</article-title>. In <source><italic>Proceedings of the Conference on Functional Programming Languages and Computer Architecture</italic> (Copenhagen, Denmark) <italic>(FPCA &#x2019;93)</italic></source>. <publisher-name>Association for Computing Machinery</publisher-name>, <publisher-loc>New York, NY, USA</publisher-loc>, <fpage>31</fpage>&#x2013;<lpage>41</lpage>. doi:10.1145/165180.165188</mixed-citation></ref>
<ref id="ref003"><label>[3]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Aiken</given-names> <surname>Alexander</surname></string-name>, <string-name><given-names>Edward L.</given-names> <surname>Wimmers</surname></string-name>, and <string-name><given-names>T. K.</given-names> <surname>Lakshman</surname></string-name></person-group>. <year>1994</year>. <article-title>Soft Typing with Conditional Types</article-title>. In <source><italic>Proceedings of the 21st ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages</italic> (Portland, Oregon, USA) <italic>(POPL &#x2019;94)</italic></source>. <publisher-name>Association for Computing Machinery</publisher-name>, <publisher-loc>New York, NY, USA</publisher-loc>, <fpage>163</fpage>&#x2013;<lpage>173</lpage>. doi:10.1145/174675.177847</mixed-citation></ref>
<ref id="ref004"><label>[4]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Alpuim</given-names> <surname>Jo&#x00E3;o</surname></string-name>, <string-name><given-names>Bruno C. d. S.</given-names> <surname>Oliveira</surname></string-name>, and <string-name><given-names>Zhiyuan</given-names> <surname>Shi</surname></string-name></person-group>. <year>2017</year>. <article-title>Disjoint Polymorphism</article-title>. In <source><italic>Programming Languages and Systems</italic></source>, <person-group person-group-type="editor"><string-name><given-names>Hongseok</given-names> <surname>Yang</surname></string-name></string-name></person-group> (Ed.). <publisher-name>Springer Berlin Heidelberg</publisher-name>, <publisher-loc>Berlin, Heidelberg</publisher-loc>, <fpage>1</fpage>&#x2013;<lpage>28</lpage>.</mixed-citation></ref>
<ref id="ref005"><label>[5]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Roberto M.</given-names> <surname>Amadio</surname></string-name> and <string-name><given-names>Luca.</given-names> <surname>Cardelli</surname></string-name></person-group>. <year>1993</year>. <article-title>Subtyping Recursive Types</article-title>. <source><italic>ACM Trans. Program. Lang. Syst</italic></source>. <volume>.</volume>, <issue>15 (4)</issue> <fpage>Sept. 1993</fpage>575</lpage>&#x2013;</lpage>. doi:10.1145/155183.155231</mixed-citation></ref>
<ref id="ref006"><label>[6]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Andrew W.</given-names> <surname>Appel</surname></string-name>, <string-name><given-names>Paul-Andr&#x00E9;</given-names> <surname>Melli&#x00E8;s</surname></string-name>, <string-name><given-names>Christopher D.</given-names> <surname>Richards</surname></string-name>, and <string-name><given-names>J&#x00E9;r&#x00F4;me</given-names> <surname>Vouillon</surname></string-name></person-group>. <year>2007</year>. <article-title>A Very Modal Model of a Modern, Major, General Type System</article-title>. In <source><italic>Proceedings of the 34th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages</italic> (Nice, France) <italic>(POPL &#x2019;07)</italic></source>. <publisher-name>Association for Computing Machinery</publisher-name>, <publisher-loc>New York, NY, USA</publisher-loc>, <fpage>109</fpage>&#x2013;<lpage>122</lpage>. doi:10.1145/1190216.1190235</mixed-citation></ref>
<ref id="ref007"><label>[7]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Sanjeev</given-names> <surname>Arora</surname></string-name> and <string-name><given-names>Boaz.</given-names> <surname>Barak</surname></string-name></person-group>. <article-title>2009</article-title>. <source><italic>Computational Complexity: A Modern Approach</italic></source> <edition>(1st ed.)</edition>. <publisher-name>Cambridge University Press</publisher-name>, <publisher-loc>USA</publisher-loc>.</mixed-citation></ref>
<ref id="ref008"><label>[8]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Bachurski</given-names> <surname>Jakub</surname></string-name>, <string-name><given-names>Alan</given-names> <surname>Mycroft</surname></string-name>, and <string-name><given-names>Dominic</given-names> <surname>Orchard</surname></string-name></person-group>. <year>2025</year>. <article-title>Structuring Arrays with Algebraic Shapes</article-title>. In <source><italic>Proceedings of the 11th ACM SIGPLAN International Workshop on Libraries, Languages and Compilers for Array Programming</italic> (Seoul, Republic of Korea) <italic>(ARRAY &#x2019;25)</italic></source>. <publisher-name>Association for Computing Machinery</publisher-name>, <publisher-loc>New York, NY, USA</publisher-loc>, <fpage>1</fpage>&#x2013;<lpage>16</lpage>. doi:10.1145/3736112.3736141</mixed-citation></ref>
<ref id="ref009"><label>[9]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Barendregt</given-names> <surname>Henk</surname></string-name>, <string-name><given-names>Mario</given-names> <surname>Coppo</surname></string-name>, and <string-name><given-names>Mariangiola</given-names> <surname>Dezani-Ciancaglini</surname></string-name></person-group>. <year>1983</year>. <article-title>A filter lambda model and the completeness of type assignment</article-title>. <source><italic>Journal of Symbolic Logic</italic></source> <volume>48</volume>, <issue>4 (1983)</issue> <fpage>931</fpage>&#x2013;</lpage>940</lpage>. doi:10.2307/2273659</mixed-citation></ref>
<ref id="ref010"><label>[10]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Bhanuka</given-names> <surname>Ishan</surname></string-name>, <string-name><given-names>Lionel</given-names> <surname>Parreaux</surname></string-name>, <string-name><given-names>David</given-names> <surname>Binder</surname></string-name>, and <string-name><given-names>Jonathan Immanuel</given-names> <surname>Brachth&#x00E4;user</surname></string-name></person-group>. <year>2023</year>. <article-title>Getting into the Flow: Towards Better Type Error Messages for Constraint-Based Type Inference</article-title>. <source><italic>Proc. ACM Program. Lang</italic></source>. <volume>7</volume>, OOPSLA2, Article 237 (Oct. 2023), <fpage>29</fpage> pages. doi:10.1145/3622812</mixed-citation></ref>
<ref id="ref011"><label>[11]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Binder</given-names> <surname>David</surname></string-name>, <string-name><given-names>Ingo</given-names> <surname>Skupin</surname></string-name>, <string-name><given-names>David</given-names> <surname>L&#x00E4;wen</surname></string-name>, and <string-name><given-names>Klaus</given-names> <surname>Ostermann</surname></string-name></person-group>. <year>2022</year>. <article-title>Structural Refinement Types</article-title>. In <source><italic>Proceedings of the 7th ACM SIGPLAN International Workshop on Type-Driven Development (TyDe &#x2019;22)</italic></source>. <publisher-name>Association for Computing Machinery</publisher-name>, <publisher-loc>New York, NY, USA</publisher-loc>. doi:10.1145/3546196.3550163</mixed-citation></ref>
<ref id="ref012"><label>[12]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Michael</given-names> <surname>Brandt</surname></string-name> and <string-name><given-names>Fritz.</given-names> <surname>Henglein</surname></string-name></person-group>. <year>1998</year>. <article-title>Coinductive axiomatization of recursive type equality and subtyping</article-title>. <source><italic>Fundamenta Informaticae</italic></source> <volume>33</volume>, <issue>4 (1998)</issue> <fpage>309</fpage>&#x2013;</lpage>338</lpage>.</mixed-citation></ref>
<ref id="ref013"><label>[13]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Giuseppe</given-names> <surname>Castagna</surname></string-name></person-group>. <article-title>2012</article-title>. <source><italic>Object-Oriented Programming A Unified Foundation</italic></source>. Springer Science &amp; Business Media.</mixed-citation></ref>
<ref id="ref014"><label>[14]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Castagna</given-names> <surname>Giuseppe</surname></string-name>, <string-name><given-names>Micka&#x00EB;l</given-names> <surname>Laurent</surname></string-name>, <string-name><given-names>Kim</given-names> <surname>Nguyundefinedn</surname></string-name>, and <string-name><given-names>Matthew</given-names> <surname>Lutze</surname></string-name></person-group>. <year>2022</year>. <article-title>On Type-Cases, Union Elimination, and Occurrence Typing</article-title>. <source><italic>Proc. ACM Program. Lang</italic></source>. <volume>6</volume>, POPL, Article 13 (Jan. 2022), <fpage>31</fpage> pages. doi:10.1145/3498674</mixed-citation></ref>
<ref id="ref015"><label>[15]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Castagna</given-names> <surname>Giuseppe</surname></string-name>, <string-name><given-names>Tommaso</given-names> <surname>Petrucciani</surname></string-name>, and <string-name><given-names>Kim</given-names> <surname>Nguyen</surname></string-name></person-group>. <year>2016</year>. <article-title>Set-theoretic types for polymorphic variants</article-title>. In <source><italic>Proceedings of the 21st ACM SIGPLAN International Conference on Functional Programming (ICFP 2016)</italic></source>. <publisher-name>Association for Computing Machinery</publisher-name>, <publisher-loc>Nara, Japan</publisher-loc>, <fpage>378</fpage>&#x2013;<lpage>391</lpage>. doi:10.1145/2951913.2951928</mixed-citation></ref>
<ref id="ref016"><label>[16]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Giuseppe</given-names> <surname>Castagna</surname></string-name> and <string-name><given-names>Lo&#x00EF;c.</given-names> <surname>Peyrot</surname></string-name></person-group>. <year>2025</year>. <article-title>Polymorphic Records for Dynamic Languages</article-title>. <source><italic>Proc. ACM Program. Lang</italic></source>. <volume>9</volume>, OOPSLA1, Article 132 (April 2025), <fpage>28</fpage> pages. doi:10.1145/3720497</mixed-citation></ref>
<ref id="ref017"><label>[17]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Chun Yin</given-names> <surname>Chau</surname></string-name> and <string-name><given-names>Lionel.</given-names> <surname>Parreaux</surname></string-name>. 2025. The Simple Essence of Boolean-Algebraic Subtyping: Semantic Soundness for Algebraic Union, Intersection, Negation, and Equi-recursive Types (Artifact). doi:10.5281/zenodo.17348546</mixed-citation></ref>
<ref id="ref018"><label>[18]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>M.</given-names> <surname>Coppo</surname></string-name> and <string-name><given-names>M.</given-names> <surname>Dezani-Ciancaglini</surname></string-name></person-group>. <year>1980</year>. <article-title>An extension of the basic functionality theory for the <italic>&#x1D706;</italic>-calculus</article-title>. <source><italic>Notre Dame Journal of Formal Logic</italic></source> <volume>21</volume>, <issue>4 (1980)</issue> <fpage>685</fpage>&#x2013;</lpage>693</lpage>. doi:10.1305/ndjfl/1093883253</mixed-citation></ref>
<ref id="ref019"><label>[19]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Stephen</given-names> <surname>Dolan</surname></string-name></person-group>. <article-title>2017</article-title>. <source><italic>Algebraic subtyping</italic></source>. Ph. D. Dissertation.</mixed-citation></ref>
<ref id="ref020"><label>[20]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Stephen</given-names> <surname>Dolan</surname></string-name> and <string-name><given-names>Alan.</given-names> <surname>Mycroft</surname></string-name></person-group>. <year>2017</year>. <article-title>Polymorphism, subtyping, and type inference in MLsub</article-title>. <source><italic>ACM SIGPLAN Notices</italic></source> <volume>52</volume>, <issue>1 (Jan. 2017)</issue> <fpage>60</fpage>&#x2013;</lpage>72</lpage>. doi:10.1145/3093333.3009882</mixed-citation></ref>
<ref id="ref021"><label>[21]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Jana</given-names> <surname>Dunfield</surname></string-name></person-group>. <year>2012</year>. <article-title>Elaborating Intersection and Union Types</article-title>. In <source><italic>Proceedings of the 17th ACM SIGPLAN International Conference on Functional Programming</italic> (Copenhagen, Denmark) <italic>(ICFP &#x2019;12)</italic></source>. <publisher-name>Association for Computing Machinery</publisher-name>, <publisher-loc>New York, NY, USA</publisher-loc>, <fpage>17</fpage>&#x2013;<lpage>28</lpage>. doi:10.1145/2364527.2364534</mixed-citation></ref>
<ref id="ref022"><label>[22]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Claudia</given-names> <surname>Faggian</surname></string-name> and <string-name><given-names>Mauro.</given-names> <surname>Piccolo</surname></string-name></person-group>. <year>2009</year>. <article-title>Partial Orders, Event Structures and Linear Strategies</article-title>. In <source><italic>Typed Lambda Calculi and Applications</italic></source>, <person-group person-group-type="editor"><string-name><given-names>Pierre-Louis</given-names> <surname>Curien</surname></string-name></string-name></person-group> (Ed.). <publisher-name>Springer Berlin Heidelberg</publisher-name>, <publisher-loc>Berlin, Heidelberg</publisher-loc>, <fpage>95</fpage>&#x2013;<lpage>111</lpage>.</mixed-citation></ref>
<ref id="ref023"><label>[23]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Frisch</given-names> <surname>Alain</surname></string-name>, <string-name><given-names>Giuseppe</given-names> <surname>Castagna</surname></string-name>, and <string-name><given-names>V&#x00E9;ronique</given-names> <surname>Benzaken</surname></string-name></person-group>. <year>2002</year>. <article-title>Semantic subtyping</article-title>. In <source><italic>Proceedings 17th Annual IEEE Symposium on Logic in Computer Science</italic></source>. 137&#x2013;146. doi:10.1109/LICS.2002.1029823</mixed-citation></ref>
<ref id="ref024"><label>[24]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Frisch</given-names> <surname>Alain</surname></string-name>, <string-name><given-names>Giuseppe</given-names> <surname>Castagna</surname></string-name>, and <string-name><given-names>V&#x00E9;ronique</given-names> <surname>Benzaken</surname></string-name></person-group>. <year>2008</year>. <article-title>Semantic Subtyping: Dealing Set-Theoretically with Function, Union, Intersection, and Negation Types</article-title>. <source><italic>J. ACM</italic></italic></source> 55, 4, Article 19 (Sept. 2008), <fpage>64</fpage> pages. doi:10.1145/1391289. 1391293</mixed-citation></ref>
<ref id="ref025"><label>[25]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Cunyuan</given-names> <surname>Gao</surname></string-name> and <string-name><given-names>Lionel.</given-names> <surname>Parreaux</surname></string-name></person-group>. <year>2025</year>. <article-title>A Lightweight Type-and-Effect System for Invalidation Safety: Tracking Permanent and Temporary Invalidation with Constraint-Based Subtype Inference</article-title>. <source><italic>Proc. ACM Program. Lang</italic></source>. <volume>9</volume>, OOPSLA2, Article 366 (Oct. 2025), <fpage>31</fpage> pages. doi:10.1145/3763144</mixed-citation></ref>
<ref id="ref026"><label>[26]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Gapeyev</given-names> <surname>Vladimir</surname></string-name>, <string-name><given-names>Michael Y.</given-names> <surname>Levin</surname></string-name>, and <string-name><given-names>Benjamin C.</given-names> <surname>Pierce</surname></string-name></person-group>. <year>2002</year>. <article-title>Recursive subtyping revealed</article-title>. <source><italic>Journal of Functional Programming</italic></source> <volume>12</volume>, <issue>6 (2002)</issue> <fpage>511</fpage>&#x2013;</lpage>548</lpage>.</mixed-citation></ref>
<ref id="ref027"><label>[27]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Jacques</given-names> <surname>Garrigue</surname></string-name></person-group>. <year>1998</year>. <article-title>Programming with polymorphic variants</article-title>. In <source><italic>ML Workshop</italic></source>, Vol. 13. Baltimore, 7.</mixed-citation></ref>
<ref id="ref028"><label>[28]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Jacques</given-names> <surname>Garrigue</surname></string-name></person-group>. <year>2000</year>. <article-title>Code reuse through polymorphic variants</article-title>. In <source><italic>In Workshop on Foundations of Software Engineering</italic></source>. <ext-link ext-link-type="uri" xlink:href="https://www.math.nagoya-u.ac.jp/~garrigue/papers/variant-reuse.pdf">https://www.math.nagoya-u.ac.jp/~garrigue/papers/variant-reuse.pdf</ext-link></mixed-citation></ref>
<ref id="ref029"><label>[29]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Jacques</given-names> <surname>Garrigue</surname></string-name></person-group>. <year>2001</year>. <article-title>Simple Type Inference for Structural Polymorphism.</article-title>. In <source><italic>APLAS</italic></italic></source>. 329&#x2013;343.</mixed-citation></ref>
<ref id="ref030"><label>[30]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Benedict R.</given-names> <surname>Gaster</surname></string-name> and <string-name><given-names>Mark P.</given-names> <surname>Jones</surname></string-name>. 1996. A Polymorphic Type System for Extensible Records and Variants.</mixed-citation></ref>
<ref id="ref031"><label>[31]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Gerhard</given-names> <surname>Gentzen</surname></string-name></person-group>. <article-title>1935a. Untersuchungen &#x00FC;ber das logische Schlie&#x00DF;en. I</article-title>. <source><italic>Mathematische Zeitschrift</italic></source> <volume>39</volume>, <issue>1 (Dec. 1935)</issue> <fpage>176</fpage>&#x2013;</lpage>210</lpage>. doi:10.1007/BF01201353</mixed-citation></ref>
<ref id="ref032"><label>[32]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Gerhard</given-names> <surname>Gentzen</surname></string-name></person-group>. <article-title>1935b. Untersuchungen &#x00FC;ber das logische Schlie&#x00DF;en. II</article-title>. <source><italic>Mathematische Zeitschrift</italic></source> <volume>39</volume>, <issue>1 (Dec. 1935)</issue> <fpage>405</fpage>&#x2013;</lpage>431</lpage>. doi:10.1007/BF01201363</mixed-citation></ref>
<ref id="ref033"><label>[33]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Silvia</given-names> <surname>Ghilezan</surname></string-name></person-group>. <year>1996</year>. <article-title>Strong Normalization and Typability with Intersection Types</article-title>. <source><italic>Notre Dame Journal of Formal Logic</italic></source> <volume>37</volume>, <issue>1 (1996)</issue> <fpage>44</fpage>&#x2013;</lpage>52</lpage>. doi:10.1305/ndjfl/1040067315</mixed-citation></ref>
<ref id="ref034"><label>[34]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Hosoya</given-names> <surname>Haruo</surname></string-name>, <string-name><given-names>J&#x00E9;r&#x00F4;me</given-names> <surname>Vouillon</surname></string-name>, and <string-name><given-names>Benjamin C.</given-names> <surname>Pierce</surname></string-name></person-group>. <year>2005</year>. <article-title>Regular Expression Types for XML</article-title>. <source><italic>ACM Trans. Program. Lang. Syst</italic></source>. <volume>.</volume>, <issue>27 (1)</issue> <fpage>Jan. 2005</fpage>46</lpage>&#x2013;</lpage>. doi:10.1145/1053468.1053470</mixed-citation></ref>
<ref id="ref035"><label>[35]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Xuejing</given-names> <surname>Huang</surname></string-name> and <string-name><given-names>Bruno C. d. S.</given-names> <surname>Oliveira</surname></string-name></person-group>. <year>2021</year>. <article-title>Distributing Intersection and Union Types with Splits and Duality (Functional Pearl)</article-title>. <source><italic>Proc. ACM Program. Lang</italic></source>. <volume>5</volume>, ICFP, Article 89 (Aug. 2021), <fpage>24</fpage> pages. doi:10.1145/3473594</mixed-citation></ref>
<ref id="ref036"><label>[36]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Trevor</given-names> <surname>Jim</surname></string-name> and <string-name><given-names>Jens.</given-names> <surname>Palsberg</surname></string-name>. 1999. Type Inference in Systems of Recursive Types With Subtyping.</mixed-citation></ref>
<ref id="ref037"><label>[37]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Lutze</given-names> <surname>Matthew</surname></string-name>, <string-name><given-names>Magnus</given-names> <surname>Madsen</surname></string-name>, <string-name><given-names>Philipp</given-names> <surname>Schuster</surname></string-name>, and <string-name><given-names>Jonathan Immanuel</given-names> <surname>Brachth&#x00E4;user</surname></string-name></person-group>. <year>2023</year>. <article-title>With or Without You: Programming with Effect Exclusion</article-title>. <source><italic>Proc. ACM Program. Lang</italic></source>. <volume>7</volume>, ICFP, Article 204 (Aug. 2023), <fpage>28</fpage> pages. doi:10.1145/ 3607846</mixed-citation></ref>
<ref id="ref038"><label>[38]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>MacQueen</given-names> <surname>David</surname></string-name>, <string-name><given-names>Gordon</given-names> <surname>Plotkin</surname></string-name>, and <string-name><given-names>Ravi</given-names> <surname>Sethi</surname></string-name></person-group>. <year>1986</year>. <article-title>An ideal model for recursive polymorphic types</article-title>. <source><italic>Information and Control</italic></source> <volume>71</volume>, <issue>1 (1986)</issue> <fpage>95</fpage>&#x2013;</lpage>130</lpage>. doi:10.1016/S0019-9958(86)80019-5</mixed-citation></ref>
<ref id="ref039"><label>[39]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Madsen</given-names> <surname>Magnus</surname></string-name>, <string-name><given-names>Jonathan Lindegaard</given-names> <surname>Starup</surname></string-name>, and <string-name><given-names>Matthew</given-names> <surname>Lutze</surname></string-name></person-group>. <year>2023</year>. <article-title>Restrictable Variants: A Simple and Practical Alternative to Extensible Variants</article-title>. In <source><italic>37th European Conference on Object-Oriented Programming (ECOOP 2023) (Leibniz International Proceedings in Informatics (LIPIcs), Vol. 263)</italic></source>, <person-group person-group-type="editor"><string-name><given-names>Karim</given-names> <surname>Ali</surname></string-name></string-name> and <string-name><given-names>Guido</given-names> <surname>Salvaneschi</surname></string-name></string-name></person-group> (Ed.). <publisher-name>Schloss Dagstuhl &#x2013; Leibniz-Zentrum f&#x00FC;r Informatik</publisher-name>, <publisher-loc>Dagstuhl, Germany</publisher-loc>, <volume>17</volume>:<fpage>1</fpage>&#x2013;<lpage>17</lpage>:27. doi:10.4230/LIPIcs.ECOOP.2023.17</mixed-citation></ref>
<ref id="ref040"><label>[40]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Magnus</given-names> <surname>Madsen</surname></string-name> and Jaco van de Pol. 2020. Polymorphic types and effects with Boolean unification. <italic>Proc. ACM Program. Lang</italic>. 4, OOPSLA, Article 154 (Nov. 2020), <fpage>29</fpage> pages. doi:10.1145/3428222</mixed-citation></ref>
<ref id="ref041"><label>[41]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Magnus</given-names> <surname>Madsen</surname></string-name> and Jaco van de Pol. 2021. Relational nullable types with Boolean unification. <italic>Proc. ACM Program. Lang</italic>. 5, OOPSLA, Article 110 (Oct. 2021), <fpage>28</fpage> pages. doi:10.1145/3485487</mixed-citation></ref>
<ref id="ref042"><label>[42]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>James Hiram</given-names> <surname>Morris</surname></string-name></person-group>. <article-title>1969</article-title>. <source><italic>Lambda-calculus models of programming languages</italic></source>. Ph. D. Dissertation. Massachusetts Institute of Technology.</mixed-citation></ref>
<ref id="ref043"><label>[43]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Fabian</given-names> <surname>Muehlboeck</surname></string-name> and <string-name><given-names>Ross.</given-names> <surname>Tate</surname></string-name></person-group>. <year>2018</year>. <article-title>Empowering Union and Intersection Types with Integrated Subtyping</article-title>. <source><italic>Proc. ACM Program. Lang</italic></source>. <volume>2</volume>, OOPSLA, Article 112 (Oct. 2018), <fpage>29</fpage> pages. doi:10.1145/3276482</mixed-citation></ref>
<ref id="ref044"><label>[44]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Odersky</given-names> <surname>Martin</surname></string-name>, <string-name><given-names>Martin</given-names> <surname>Sulzmann</surname></string-name>, and <string-name><given-names>Martin</given-names> <surname>Wehr</surname></string-name></person-group>. <year>1999</year>. <article-title>Type inference with constrained types</article-title>. <source><italic>Theory and Practice of Object Systems</italic></source> <volume>5</volume>, <issue>1 (1999)</issue> <fpage>35</fpage>&#x2013;</lpage>55</lpage>.</mixed-citation></ref>
<ref id="ref045"><label>[45]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Atsushi</given-names> <surname>Ohori</surname></string-name></person-group>. <year>1995</year>. <article-title>A Polymorphic Record Calculus and Its Compilation</article-title>. <source><italic>ACM Trans. Program. Lang. Syst</italic></source>. <volume>.</volume>, <issue>17 (6)</issue> <fpage>Nov. 1995</fpage>844</lpage>&#x2013;</lpage>. doi:10.1145/218570.218572</mixed-citation></ref>
<ref id="ref046"><label>[46]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Bruno C. d. S.</given-names> <surname>Oliveira</surname></string-name>, <string-name><given-names>Cui</given-names> <surname>Shaobo</surname></string-name>, and <string-name><given-names>Baber</given-names> <surname>Rehman</surname></string-name>. 2020. The Duality of Subtyping. (2020), 29 pages, 728719 bytes. doi:10.4230/LIPICS.ECOOP.2020.29</mixed-citation></ref>
<ref id="ref047"><label>[47]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Lionel</given-names> <surname>Parreaux</surname></string-name></person-group>. <year>2020</year>. <article-title>The Simple Essence of Algebraic Subtyping: Principal Type Inference with Subtyping Made Easy (Functional Pearl)</article-title>. <source><italic>Proc. ACM Program. Lang</italic></source>. <volume>4</volume>, ICFP, Article 124 (Aug. 2020), <fpage>28</fpage> pages. doi:10.1145/3409006</mixed-citation></ref>
<ref id="ref048"><label>[48]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Parreaux</given-names> <surname>Lionel</surname></string-name>, <string-name><given-names>Aleksander</given-names> <surname>Boruch-Gruszecki</surname></string-name>, <string-name><given-names>Andong</given-names> <surname>Fan</surname></string-name>, and <string-name><given-names>Chun Yin</given-names> <surname>Chau</surname></string-name></person-group>. <year>2024</year>. <article-title>When Subtyping Constraints Liberate: A Novel Type Inference Approach for First-Class Polymorphism</article-title>. <source><italic>Proc. ACM Program. Lang</italic></source>. <volume>8</volume>, POPL, Article 48 (Jan. 2024), <fpage>33</fpage> pages. doi:10.1145/3632890</mixed-citation></ref>
<ref id="ref049"><label>[49]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Lionel</given-names> <surname>Parreaux</surname></string-name> and Chun Yin Chau. 2022a. MLstruct: principal type inference in a Boolean algebra of structural types. <italic>Proc. ACM Program. Lang</italic>. 6, OOPSLA2, Article 141 (Oct. 2022), <fpage>30</fpage> pages. doi:10.1145/3563304</mixed-citation></ref>
<ref id="ref050"><label>[50]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Lionel</given-names> <surname>Parreaux</surname></string-name> and Chun Yin Chau. 2022b. <italic>MLstruct: Principal Type Inference in a Boolean Algebra of Structural Types (Extended Version)</italic>. Technical Report. The Hong Kong University of Science and Technology. <ext-link ext-link-type="uri" xlink:href="https://lptk.github.io/">https://lptk.github.io/</ext-link> mlscript-paper</mixed-citation></ref>
<ref id="ref051"><label>[51]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Tommaso</given-names> <surname>Petrucciani</surname></string-name></person-group>. <article-title>2019</article-title>. <source><italic>Polymorphic set-theoretic types for functional languages</italic></source>. Ph. D. Dissertation. Universit&#x00E0; di Genova; Universit&#x00E9; Sorbonne Paris Cit&#x00E9;&#x2013; Universit&#x00E9; Paris Diderot.</mixed-citation></ref>
<ref id="ref052"><label>[52]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Benjamin C.</given-names> <surname>Pierce</surname></string-name></person-group>. <article-title>1991</article-title>. <source><italic>Programming with intersection types and bounded polymorphism</italic></source>. Ph. D. Dissertation. Citeseer. Benjamin C. Pierce. 2002. <italic>Types and programming languages</italic>. <publisher-name>MIT press</publisher-name>.</mixed-citation></ref>
<ref id="ref053"><label>[53]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Fran&#x00E7;ois</given-names> <surname>Pottier</surname></string-name></person-group>. <article-title>1998</article-title>. <source><italic>Type Inference in the Presence of Subtyping: from Theory to Practice</italic></source>. Research Report RR-3483. INRIA. <ext-link ext-link-type="uri" xlink:href="https://hal.inria.fr/inria-00073205">https://hal.inria.fr/inria-00073205</ext-link></mixed-citation></ref>
<ref id="ref054"><label>[54]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Rehman</given-names> <surname>Baber</surname></string-name>, <string-name><given-names>Xuejing</given-names> <surname>Huang</surname></string-name>, <string-name><given-names>Ningning</given-names> <surname>Xie</surname></string-name>, and <string-name><given-names>Bruno C. d. S.</given-names> <surname>Oliveira</surname></string-name></person-group>. <year>2022</year>. <article-title>Union Types with Disjoint Switches</article-title>. In <source><italic>36th European Conference on Object-Oriented Programming (ECOOP 2022) (Leibniz International Proceedings in Informatics (LIPIcs), Vol. 222)</italic></source>, <person-group person-group-type="editor"><string-name><given-names>Karim</given-names> <surname>Ali</surname></string-name></string-name> and <string-name><given-names>Jan</given-names> <surname>Vitek</surname></string-name></string-name></person-group> (Ed.). <publisher-name>Schloss Dagstuhl &#x2013; Leibniz-Zentrum f&#x00FC;r Informatik</publisher-name>, <publisher-loc>Dagstuhl, Germany</publisher-loc>, <volume>25</volume>:<fpage>1</fpage>&#x2013;<lpage>25</lpage>:31. doi:10.4230/LIPIcs.ECOOP.2022.25</mixed-citation></ref>
<ref id="ref055"><label>[55]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Didier</given-names> <surname>R&#x00E9;my</surname></string-name></person-group>. <article-title>1994</article-title>. <source><italic>Type Inference for Records in Natural Extension of ML</italic></source>. <publisher-name>MIT Press</publisher-name>, <publisher-loc>Cambridge, MA, USA</publisher-loc>, <fpage>67</fpage>&#x2013;</lpage>95</lpage>.</mixed-citation></ref>
<ref id="ref056"><label>[56]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>John C.</given-names> <surname>Reynolds</surname></string-name></person-group>. <article-title>1997</article-title>. <source><italic>Design of the Programming Language Forsythe</italic></source>. <publisher-name>Birkh&#x00E4;user Boston</publisher-name>, <publisher-loc>Boston, MA</publisher-loc>, <fpage>173</fpage>&#x2013;</lpage>233</lpage>. doi:10. <year>1007</year>/978-1-4612-4118-8_9</mixed-citation></ref>
<ref id="ref057"><label>[57]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Sulzmann</given-names> <surname>Martin</surname></string-name>, <string-name><given-names>Martin</given-names> <surname>M&#x00FC;ller</surname></string-name>, and <string-name><given-names>Christoph</given-names> <surname>Zenger</surname></string-name></person-group>. <year>1999</year>. <article-title>Hindley/Milner style type systems in constraint form</article-title>. <source><italic>Res. Rep. ACRC-99-009, University of South Australia, School of Computer and Information Science</italic></source> (1999).</mixed-citation></ref>
<ref id="ref058"><label>[58]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Valery</given-names> <surname>Trifonov</surname></string-name> and <string-name><given-names>Scott.</given-names> <surname>Smith</surname></string-name></person-group>. <year>1996</year>. <article-title>Subtyping constrained types</article-title>. In <source><italic>Static Analysis</italic></source>, Radhia Cousot and David A. Schmidt (Eds.). <publisher-name>Springer Berlin Heidelberg</publisher-name>, <publisher-loc>Berlin, Heidelberg</publisher-loc>, <fpage>349</fpage>&#x2013;<lpage>365</lpage>.</mixed-citation></ref>
<ref id="ref059"><label>[59]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Leo</given-names> <surname>White</surname></string-name>. 2015. Row polymorphism. <ext-link ext-link-type="uri" xlink:href="https://www.cl.cam.ac.uk/teaching/1415/L28/rows.pdf">https://www.cl.cam.ac.uk/teaching/1415/L28/rows.pdf</ext-link></mixed-citation></ref>
<ref id="ref060"><label>[60]</label><mixed-citation publication-type="journal"><person-group person-group-type="author"><string-name><given-names>Litao</given-names> <surname>Zhou</surname></string-name> and <string-name><given-names>Bruno C. d. S.</given-names> <surname>Oliveira</surname></string-name></person-group>. <year>2025</year>. <article-title>QuickSub: Efficient Iso-Recursive Subtyping</article-title>. <source><italic>Proc. ACM Program. Lang</italic></source>. <volume>9</volume>, POPL, Article 33 (Jan. 2025), <fpage>32</fpage> pages. doi:10.1145/3704869</mixed-citation></ref>
</ref-list>
<fn-group>
<fn id="1">This example is formulated in MLstruct<sup>+</sup> syntax, a slight variation on the original MLstruct syntax.</fn>
<fn id="2">Technically speaking, it can be an instance of any <italic>subtag</italic> of <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathsf{Some}$]]></texMath></inlineMaths>.</fn>
<fn id="3">For example, it can be used to implement the extensible programming pattern described by Garrigue [2000]. A more detailed comparison with polymorphic variants is provided in Section 6 and by Parreaux and Chau [2022b].</fn>
<fn id="4">https://github.com/lampepfl/dotty-feature-requests/issues/51</fn>
<fn id="5">This introductory description omits considerations of coinductive assumption contexts, which we detail later.</fn>
<fn id="6">In MLstruct, the pattern matching construct uses a slightly more complex <monospace>case</monospace> expression form, which is nonetheless equivalent (each syntax can be encoded in the other), as explained below.</fn>
<fn id="7">Technically, tags could be left to form any <italic>arborescent partial order</italic> [Faggian and Piccolo 2009], but rooting them all into a single <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$\mathsf{Obj}$]]></texMath></inlineMaths> base tag simplifies the development and reasoning slightly.</fn>
<fn id="8">Indeed, under inconsistent bounds, ill-typed terms become typeable. For example, we have <inlineMaths><graphic id="oso-9780199563487-chapter-8-graphic-9" electronicRight="Y" sysId="oso-9780199563487-math-0009.gif" role="inline"/><texMath><![CDATA[$(\tyCtor{Int=<\tyCtor{Int&#x2192;\tyCtor{Int) |- 1\ 1: \mathsf{Int}$]]></texMath></inlineMaths>.</fn>
<fn id="9">Requiring T-B<sc>ody</sc> to type the body of the program in an empty context would be sufficient but too restrictive, for the reason mentioned above relating to recursive types &#x2014; we could then not define a complete type inference algorithm for it.</fn>
<fn id="10">The first author of this paper has received  emails from various people reimplementing Simple-sub [Parreaux 2020] and wanting to know how to add support for first-class union and intersection types, showing the enduring interest in these.</fn>
</fn-group>
</back>
</article>